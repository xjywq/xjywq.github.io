<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Avltree</title>
    <url>/2020/7/2/Avltree/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>平衡树是基于二叉查找树的一种数据结构,添加了更加严格的管理制度用以保证树的高度,即<strong>每一个节点的左右子树深度之差</strong>不超过 1.</li>
<li>但是条件可能过于严格,导致插入和删除的操作会导致数据大量的移动.<a id="more"></a>

</li>
</ul>
<h2 id="结构实现"><a href="#结构实现" class="headerlink" title="结构实现"></a>结构实现</h2><ul>
<li>储存方式依旧是二叉树储存,对于每个节点需要添加一个关键字<code>depth</code>用来储存该节点的深度.</li>
<li>对于插入操作,可能会引起深度的变化导致失衡,我们把失衡的节点叫做危机节点,此时需要调整危机节点及周围节点.</li>
<li>对于删除操作,和插入同理.</li>
<li>查找与二叉树相同,此处不在赘述.</li>
</ul>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>选用 C++实现 avl 树的构建.</p>
<h3 id="avl-树的构建"><a href="#avl-树的构建" class="headerlink" title="avl 树的构建"></a>avl 树的构建</h3><ul>
<li>对于节点,需要定义两颗子树,数据部分以及深度 4 个变量.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">avlTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Type content;</span><br><span class="line">        node *left;</span><br><span class="line">        node *right;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h3><ul>
<li>构造函数和析构函数与普通二叉树相同</li>
<li>查找函数和清空函数也完全相同</li>
</ul>
<h3 id="获取树的深度"><a href="#获取树的深度" class="headerlink" title="获取树的深度"></a>获取树的深度</h3><ul>
<li>我们需要创建一个函数更新树的深度, 对于每一个叶子节点, 深度为 1.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_depth</span><span class="params">(Node *node)</span> <span class="comment">// update node's depth</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l_depth = (node-&gt;left == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;left-&gt;depth;</span><br><span class="line">    <span class="keyword">int</span> r_depth = (node-&gt;right == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;right-&gt;depth;</span><br><span class="line">    node-&gt;depth = <span class="number">1</span> + <span class="built_in">std</span>::<span class="built_in">max</span>(l_depth, r_depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同时我们还需要一个函数在后续更方便的获取深度, 或者我们可以使用定义的方式.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_depth</span><span class="params">(<span class="keyword">const</span> Node *node)</span>    <span class="comment">// get_depth</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (node == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define Get_depth(p) ((p==NULL) ? 0 : (((Node *)(p))-&gt;height))</span></span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li>对于一般的插入,我们只需要从下至上修改节点的深度即可</li>
<li>如果遇到节点失衡,一般来说会有四种情况, 我们先假设插入到 <strong>A</strong> 节点左节点的左节点, 如图中 <strong>F</strong> 节点为插入节点:<br><img src="https://raw.githubusercontent.com/xjywq/picgo/master/avltree1.jpg" alt="avltree1"><br>此时需要将危机节点左节点的右子树变成右节点的左子树, 同样是做一次旋转使得 <strong>A</strong> 下放, <strong>B</strong> 上升, 注意 <strong>D</strong> 节点的位置, 旋转结果如下:<br><img src="https://raw.githubusercontent.com/xjywq/picgo/master/avltree2.jpg" alt="avltree2"><br>这种方法我们一般称之为单旋转, 即只需要做一次旋转即可, 如图中插入左节点的左节点, 这种旋转方法被称为 <strong>LL</strong> 方法.<br>同样右节点的右节点插入失衡的调节我们称之为 <strong>RR</strong> 方法.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">avlRotate_LL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *new_root = node-&gt;left;</span><br><span class="line">    node-&gt;left = new_root-&gt;right;</span><br><span class="line">    new_root-&gt;right = node;</span><br><span class="line">    update_depth(node);</span><br><span class="line">    update_depth(new_root);</span><br><span class="line">    <span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于 <strong>RR</strong> 方法, 只需要反过来即可.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">avlRotate_RR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *new_root = node-&gt;right;</span><br><span class="line">    node-&gt;right = new_root-&gt;left;</span><br><span class="line">    new_root-&gt;left = node;</span><br><span class="line">    update_depth(node);</span><br><span class="line">    update_depth(new_root);</span><br><span class="line">    <span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果插入节点在危机节点左节点的右节点, 用 <strong>LL</strong> 方法则会出现不平衡.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xjywq/picgo/master/avltree3.jpg" alt="avltree3"></p>
<p>所以我们需要先对 <strong>A</strong> 的左节点 <strong>B</strong> 进行一次 <strong>RR</strong> 旋转, 使 <strong>A</strong> 转变为单旋转的情况, 然后再对 <strong>A</strong> 进行 <strong>LL</strong> 旋转得到正确结果.</p>
<p><img src="https://raw.githubusercontent.com/xjywq/picgo/master/avltree4.jpg" alt="avltree4"><br><img src="https://raw.githubusercontent.com/xjywq/picgo/master/avltree5.jpg" alt="avltree5"></p>
<p>这种方法用到了两次旋转, 所以被称为双旋转, 或者 <strong>LR</strong> 方法.<br>同样我们也可以类似得出 <strong>RL</strong> 方法.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">avlRotate_LR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    avlRotate_RR(node-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> avlRotate_LL(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">avlRotate_RL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    avlRotate_LL(node-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> avlRotate_RR(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是插入函数的具体实现, 由于需要用到递归, 所以显然需要一个包装函数. 直接上代码, 解释都在代码中.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> new_content)</span>    <span class="comment">// 包装函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_node;</span><br><span class="line">        new_node = <span class="keyword">new</span> Node(new_content);</span><br><span class="line">        Root = Insert(Root, new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">Insert</span><span class="params">(Node *root, Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;content == node-&gt;content) <span class="comment">// 找到目标节点, 递归终止</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &gt; node-&gt;content) <span class="comment">// 目标节点在左节点中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = Insert(root-&gt;left, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>) <span class="comment">// 出现不平衡了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left-&gt;content &gt; node-&gt;content) <span class="comment">// 单旋转情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left-&gt;content &lt; node-&gt;content) <span class="comment">// 双旋转情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; node-&gt;content) <span class="comment">// 目标节点在右节点中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = Insert(root-&gt;right, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>) <span class="comment">// 同上</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right-&gt;content &gt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right-&gt;content &lt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        update_depth(root); <span class="comment">// 更新节点深度</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除节点的基本思路同插入相同, 当插入节点为叶子节点或者只有一个子树时, 只需要重新更新节点深度, 并做旋转更新即可. 但是当插入节点为非叶子节点时, 需要寻找叶子节点中的代替节点, 将代替节点替换为当前节点, 从而将问题转变为删除叶子节点.</p>
<p>我所采用的方法是寻找左子树中最大的节点或者右子树中最小的节点(视左右子树的高度为定), 当然也有方法是全部使用一种节点, 这样最多多做两次旋转, 并没有很大的差距.</p>
<p>当然, 删除函数也需要做一次包装, 我希望删除函数返回一个 <strong>bool</strong> 值, 如果删除值在树中则返回<code>True</code>, 否则返回<code>False</code>, 这时就需要用到查找函数.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Type &amp;n)</span> <span class="comment">// 包装函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(n) == <span class="literal">NULL</span>) <span class="comment">// 查找失败返回False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Node *node;</span><br><span class="line">        node = <span class="keyword">new</span> Node(n);</span><br><span class="line">        Root = DELETE(Root, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">DELETE</span><span class="params">(Node *root, Node *del)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || del == <span class="literal">NULL</span>) <span class="comment">// 防止错误, 此处并无作用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;content &gt; del-&gt;content) <span class="comment">// 删除节点在左子树中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = DELETE(root-&gt;left, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>) <span class="comment">// 出现危机节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; del-&gt;content) <span class="comment">// 删除节点在右子树中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = DELETE(root-&gt;right, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 当前节点就是删除节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) <span class="comment">// 如果当前节点有左右子树, 即是非叶子节点, 那么寻找最深的临近节点做替换</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right) &gt; Get_depth(root-&gt;left)) <span class="comment">// 右子树深度大</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node *right = root-&gt;right;</span><br><span class="line">                    <span class="keyword">while</span> (right-&gt;left)</span><br><span class="line">                        right = right-&gt;left; <span class="comment">// 循环获取最深的节点</span></span><br><span class="line">                    root-&gt;content = right-&gt;content;</span><br><span class="line">                    root-&gt;right = DELETE(root-&gt;right, root); <span class="comment">// 从右子树中删除该叶子节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node *left = root-&gt;left;</span><br><span class="line">                    <span class="keyword">while</span> (left-&gt;right)</span><br><span class="line">                        left = left-&gt;right;</span><br><span class="line">                    root-&gt;content = left-&gt;content;</span><br><span class="line">                    root-&gt;left = DELETE(root-&gt;left, root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 当前节点只有一个子树或者是叶子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node *tmp = root;</span><br><span class="line">                root = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(tmp); <span class="comment">// 释放空间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update_depth(root); <span class="comment">// 更新深度</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AvlTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Type content;</span><br><span class="line">        Node *left;</span><br><span class="line">        Node *right;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line">        Node(<span class="keyword">const</span> Type &amp;c) : content(c), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), depth(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_depth</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> l_depth = (node-&gt;left == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;left-&gt;depth;</span><br><span class="line">        <span class="keyword">int</span> r_depth = (node-&gt;right == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;right-&gt;depth;</span><br><span class="line">        node-&gt;depth = <span class="number">1</span> + <span class="built_in">std</span>::<span class="built_in">max</span>(l_depth, r_depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Get_depth</span><span class="params">(<span class="keyword">const</span> Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> node-&gt;depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_LL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_root = node-&gt;left;</span><br><span class="line">        node-&gt;left = new_root-&gt;right;</span><br><span class="line">        new_root-&gt;right = node;</span><br><span class="line">        update_depth(node);</span><br><span class="line">        update_depth(new_root);</span><br><span class="line">        <span class="keyword">return</span> new_root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_RR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_root = node-&gt;right;</span><br><span class="line">        node-&gt;right = new_root-&gt;left;</span><br><span class="line">        new_root-&gt;left = node;</span><br><span class="line">        update_depth(node);</span><br><span class="line">        update_depth(new_root);</span><br><span class="line">        <span class="keyword">return</span> new_root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_LR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        avlRotate_RR(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> avlRotate_LL(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_RL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        avlRotate_LL(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> avlRotate_RR(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OutPut</span><span class="params">(<span class="keyword">const</span> Node *node)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        OutPut(node-&gt;left);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; node-&gt;content &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        OutPut(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">Insert</span><span class="params">(Node *root, Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;content == node-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &gt; node-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = Insert(root-&gt;left, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left-&gt;content &gt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left-&gt;content &lt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; node-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = Insert(root-&gt;right, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right-&gt;content &gt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right-&gt;content &lt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        update_depth(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">DELETE</span><span class="params">(Node *root, Node *del)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || del == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;content &gt; del-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = DELETE(root-&gt;left, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; del-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = DELETE(root-&gt;right, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right) &gt; Get_depth(root-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    Node *right = root-&gt;right;</span><br><span class="line">                    <span class="keyword">while</span> (right-&gt;left)</span><br><span class="line">                        right = right-&gt;left;</span><br><span class="line">                    root-&gt;content = right-&gt;content;</span><br><span class="line">                    root-&gt;right = DELETE(root-&gt;right, root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node *left = root-&gt;left;</span><br><span class="line">                    <span class="keyword">while</span> (left-&gt;right)</span><br><span class="line">                        left = left-&gt;right;</span><br><span class="line">                    root-&gt;content = left-&gt;content;</span><br><span class="line">                    root-&gt;left = DELETE(root-&gt;left, root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node *tmp = root;</span><br><span class="line">                root = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update_depth(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            Clear(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            Clear(node-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Node *Root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AvlTree() : Root(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        OutPut(Root);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> new_content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_node;</span><br><span class="line">        new_node = <span class="keyword">new</span> Node(new_content);</span><br><span class="line">        Root = Insert(Root, new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">find</span><span class="params">(<span class="keyword">const</span> Type &amp;n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *root = Root;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span> &amp;&amp; root-&gt;content != n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;content &gt; n)</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; n)</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Type &amp;n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(n) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Node *node;</span><br><span class="line">        node = <span class="keyword">new</span> Node(n);</span><br><span class="line">        Root = DELETE(Root, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Clear(Root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AvlTree&lt;<span class="keyword">int</span>&gt; avl;</span><br><span class="line">    avl.insert(<span class="number">1</span>);</span><br><span class="line">    avl.insert(<span class="number">2</span>);</span><br><span class="line">    avl.insert(<span class="number">3</span>);</span><br><span class="line">    avl.insert(<span class="number">4</span>);</span><br><span class="line">    avl.insert(<span class="number">5</span>);</span><br><span class="line">    avl.insert(<span class="number">6</span>);</span><br><span class="line">    avl.insert(<span class="number">7</span>);</span><br><span class="line">    avl.insert(<span class="number">8</span>);</span><br><span class="line">    avl.<span class="built_in">print</span>();</span><br><span class="line">    avl.Delete(<span class="number">4</span>);</span><br><span class="line">    avl.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">bool</span> a = avl.Delete(<span class="number">12</span>);</span><br><span class="line">    avl.<span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    avl.<span class="built_in">clear</span>();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有疑问请加 QQ 联系我.</p>
]]></content>
      <categories>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/7/1/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown_case</title>
    <url>/2020/7/2/markdown-case/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单的 markdown 编辑实例</p>
<a id="more"></a>

<h2 id="1-语言介绍"><a href="#1-语言介绍" class="headerlink" title="1. 语言介绍"></a>1. 语言介绍</h2><p><strong>Markdown</strong> 是一种可以使用普通文本编辑器编写的标记语言, 通过简单的标记语法, 它可以使普通文本内容具有一定的格式.</p>
<h2 id="2-兼容-HTML"><a href="#2-兼容-HTML" class="headerlink" title="2. 兼容 HTML"></a>2. 兼容 HTML</h2><p>Markdown 语法的目标是:成为一种适用于网络的书写语言.</p>
<h2 id="3-标题"><a href="#3-标题" class="headerlink" title="3. 标题"></a>3. 标题</h2><ul>
<li>使用<code>#</code>标记标题, 最多可以有 6 级标题.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>-</code>或者<code>=</code>标记标题, 仅支持二级标题.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>-</code>, <code>=</code>或者<code>*</code>可以指定无序标签</li>
</ul>
<ol>
<li>直接使用数字可以形成有序标签, 值得注意的是, 数字显示的标签与输入的数字无关<ol>
<li>另外, 使用制表符也可以轻易的形成嵌套结构</li>
</ol>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>使用<span class="code">`-`</span>, <span class="code">`=`</span>或者<span class="code">`*`</span>可以指定无序标签</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>直接使用数字可以形成有序标签, 值得注意的是, 数字显示的标签与输入的数字无关</span><br><span class="line"><span class="bullet">   1. </span>另外, 使用制表符也可以轻易的形成嵌套结构</span><br></pre></td></tr></table></figure>

<h2 id="4-段落"><a href="#4-段落" class="headerlink" title="4. 段落"></a>4. 段落</h2><p>markdown 没有特殊的段落格式要求, 主要因为 markdown 是基于文本构建, 所以不能让文本编辑过于复杂.<br>只需要在段落的最后添加两个空格或者留下一段空行即可换行.</p>
<h2 id="5-字体"><a href="#5-字体" class="headerlink" title="5. 字体"></a>5. 字体</h2><p>markdown 支持以下字体:</p>
<ul>
<li><em>斜体文本</em>.</li>
<li><em>斜体文本</em>.</li>
<li><strong>粗体文本</strong>.</li>
<li><strong>粗体文本</strong>.</li>
<li><strong><em>粗斜体文本</em></strong>.</li>
<li><strong><em>粗斜体文本</em></strong>.</li>
<li><del>删除文本</del>.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">_斜体文本_</span>.</span><br><span class="line"><span class="emphasis">_斜体文本_</span>.</span><br><span class="line"><span class="strong">**粗体文本**</span>.</span><br><span class="line"><span class="strong">**粗体文本**</span>.</span><br><span class="line"><span class="strong">**_粗斜体文本_*</span>*.</span><br><span class="line"><span class="strong">**_粗斜体文本_*</span>*.</span><br><span class="line">~~删除文本~~.</span><br></pre></td></tr></table></figure>

<h2 id="6-HTML-标签在-markdown-中的使用"><a href="#6-HTML-标签在-markdown-中的使用" class="headerlink" title="6. HTML 标签在 markdown 中的使用"></a>6. HTML 标签在 markdown 中的使用</h2><p>HTML 标签在 markdown 渲染时会自动转化.</p>
<ul>
<li>我们可以<mark>高亮文字</mark>.</li>
<li>可以<ins>添加文字下划线</ins>.</li>
<li>可以用另一种方法实现<del>删除线</del>.</li>
<li>或者可以<font color="red">修改字体颜色</font>.</li>
<li>为<ruby>生僻<rt>shēng pì</rt></ruby>字添加注音.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>我们可以<span class="xml"><span class="tag">&lt;<span class="name">mark</span>&gt;</span></span>高亮文字<span class="xml"><span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>可以<span class="xml"><span class="tag">&lt;<span class="name">ins</span>&gt;</span></span>添加文字下划线<span class="xml"><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>可以用另一种方法实现<span class="xml"><span class="tag">&lt;<span class="name">del</span>&gt;</span></span>删除线<span class="xml"><span class="tag">&lt;/<span class="name">del</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>或者可以<span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span></span>修改字体颜色等等<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>为<span class="xml"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span>生僻<span class="xml"><span class="tag">&lt;<span class="name">rt</span>&gt;</span></span>shēng pì<span class="xml"><span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span>字添加注音.</span><br></pre></td></tr></table></figure>

<h2 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7. 分割线"></a>7. 分割线</h2><p>实现原理很简单, 三个(或以上)连续的<code>-</code>或者<code>*</code>即可.</p>
<hr>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="7-注释"><a href="#7-注释" class="headerlink" title="7. 注释"></a>7. 注释</h2><p>markdown 对于文本注释的支持非常好[^非常好].<br>[^非常好]:所有的标注会自动编号并放在文章末尾</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">markdown 对于文本注释的支持非常好[^非常好].</span><br><span class="line">[<span class="symbol">^非常好</span>]:<span class="link">所有的标注会自动编号并放在文章末尾</span></span><br></pre></td></tr></table></figure>

<h2 id="8-代码区"><a href="#8-代码区" class="headerlink" title="8. 代码区"></a>8. 代码区</h2><p>使用 ` 符号可以形成行内代码词, 而三个 ` 则会形成代码块.<br>或者直接使用制表符(4 个空格)加在每行前面可以达到同样代码块的效果.</p>
<h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9. 表格"></a>9. 表格</h2><p>使用<code>|</code>符号来制作表格, 使用<code>:</code>来提示对齐方向.</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="center">班级</th>
<th align="right">成绩</th>
</tr>
</thead>
<tbody><tr>
<td align="left">xjywq</td>
<td align="center">1</td>
<td align="right">100</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 姓名  | 班级 | 成绩 |</span><br><span class="line">| :---- | :--: | ---: |</span><br><span class="line">| xjywq |  1   |  100 |</span><br></pre></td></tr></table></figure>

<h2 id="10-链接"><a href="#10-链接" class="headerlink" title="10. 链接"></a>10. 链接</h2><ul>
<li>可以使用<code>[]</code>符号管理显示的链接名称, <code>()</code>符号管理链接方向, <code>&quot;&quot;</code>符号管理链接标题, 如<a href="www.baidu.com" title="百度搜索">百度</a>.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">www.baidu.com "百度搜索"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>或者可以用<code>&lt;&gt;</code>显式指定链接, 如<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.baidu.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>或者可以使用注释类型, 将 7 和 10 结合, 如<a href="www.baidu.com" title="百度搜索">百度</a>, 但是注释之间必须留一个空行.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>][<span class="symbol">baidu</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">baidu</span>]: <span class="link">www.baidu.com "百度搜索"</span></span><br></pre></td></tr></table></figure>

<h2 id="11-图片"><a href="#11-图片" class="headerlink" title="11. 图片"></a>11. 图片</h2><ul>
<li>使用链接的格式, 但是在开头加上<code>!</code>, 链接地址使用本地路径(支持绝对路径与相对路径), 在 hexo 上无法正确显示, 需要文件的相对位置, 且位置起始地址为 sourse 文件夹下.</li>
</ul>
<p><img src="/picture/markdown-case/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg" alt="麻衣学姐"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">普通 markdown 文件中:</span><br><span class="line">![<span class="string">麻衣学姐</span>](<span class="link">/markdown-case/麻衣学姐.jpg</span>)</span><br><span class="line"></span><br><span class="line">在 hexo 中则是:</span><br><span class="line">![<span class="string">麻衣学姐</span>](<span class="link">/picture/markdown-case/麻衣学姐.jpg</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用在线图床, 同上</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xjywq/picgo/master/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg" alt="麻衣学姐" title="这是我的老婆"></p>
<ul>
<li>使用 HTML 语法</li>
</ul>
<img src="https://raw.githubusercontent.com/xjywq/picgo/master/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg" alt = "麻衣学姐">

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hhttps://raw.githubusercontent.com/xjywq/picgo/master/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg"</span> <span class="attr">alt</span> = <span class="string">"麻衣学姐"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="13-公式"><a href="#13-公式" class="headerlink" title="13. 公式"></a>13. 公式</h2><ul>
<li>markdown 可以通过简单的语法插入公式, 首先是通过<code>$</code>符号, 如$\frac{1+2}{2}=1.5$, 或者另一起一行作为独立公式$$\sum_{i=0}^n{\frac 1 n}=\infty$$</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内公式</span><br><span class="line">$\frac&#123;1+2&#125;&#123;2&#125;=1.5$</span><br><span class="line"></span><br><span class="line">单独公式</span><br><span class="line">$$\sum_&#123;i=0&#125;^n&#123;\frac 1 n&#125;=\infty$$</span><br></pre></td></tr></table></figure>

<ul>
<li><p>或者使用<a href="https://www.codecogs.com/eqnedit.php" target="_blank" rel="noopener">在线公式编辑器</a>, 可以复制得到的图像或者借助于下方的 HTML 方法</p>
</li>
<li><p>H 也可以直接手动使用 HTML 方法, 借助<a href="http://chart.googleapis.com/chart" target="_blank" rel="noopener">google chart</a>或者其他</p>
</li>
</ul>
<img src="http://chart.googleapis.com/chart?cht=tx&chl= \sum_{i=0}^n{\frac 1 n}=\infty" style="border:none;">

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">谷歌服务器</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://chart.googleapis.com/chart?cht=tx&amp;chl= \sum_&#123;i=0&#125;^n&#123;\frac 1 n&#125;=\infty"</span> <span class="attr">style</span>=<span class="string">"border:none;"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在这里贴一下一位大佬的<a href="https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan" target="_blank" rel="noopener">LaTeX 数学公式大全</a>, 很好用</p>
<h2 id="14-mermaid-使用"><a href="#14-mermaid-使用" class="headerlink" title="14. mermaid 使用"></a>14. mermaid 使用</h2><ul>
<li>部分 markdown 编辑器支持 mermaid 的流程图渲染等等, 可惜 hexo 并不支持这点(暂时没有装插件的打算, 可能以后会考虑)</li>
<li>可以看看 CSDN 上大佬发的 mermaid<a href="https://blog.csdn.net/weixin_33901641/article/details/90303528?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase" target="_blank" rel="noopener">实用教程</a></li>
</ul>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>文本编辑</tag>
      </tags>
  </entry>
  <entry>
    <title>catch_the_cat</title>
    <url>/2020/9/9/catch_the_cat/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在小猫周围建墙, 阻止它逃走吧, 不要让它跑到周围的地方哦<br><img src="https://raw.githubusercontent.com/xjywq/picgo/master/catch_the_cat.jpg" alt="demo"></p>
<a id="more"></a>

<h2 id="地址链接"><a href="#地址链接" class="headerlink" title="地址链接"></a>地址链接</h2><p><a href="https://xjywq.github.io/catch_the_cat" target="_blank" rel="noopener" title="小游戏">小游戏地址</a></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在hexo的resource文件夹下建立catch_the_cat文件夹, 将js文件放在里面, 通过链接跳转即可</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">小游戏地址</span>](<span class="link">https://xjywq.github.io/catch_the_cat "小游戏"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>有机会我自己用js写一个五子棋试试, 在做了在做了.jpg</p>
]]></content>
      <tags>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>k近邻法</title>
    <url>/2020/9/9/k%E8%BF%91%E9%82%BB%E6%B3%95/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一种基本分类及回归方法. 我们仅仅考虑分类问题中的k近邻法. k近邻法的输入为实例的特征向量, 对应特征空间中的点; 输出为实例的类别, 可以有多种类别. 分类时, 根据其k个最近的训练实例的类别, 通过多数表决的方式进行预测. 因此, k近邻法不具有显式的学习过程, 实际是是对特征空间的划分, 以此为依据作为分类的”模型”.</p>
<p>k近邻法于1968年由Cover和Hart提出.</p>
<a id="more"></a>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>给定数据集<br>$$T=\ { (x_1,y_1),(x_2,y_2),…,(x_N,y_N)\ } $$<br>其中, $x_i$为实例的特征向量, $y_i$为实例的具体分类. $k$近邻旨在使用邻近的$k$个节点的分类得到实例所处的特征空间分类, 最终得到实例的分类, 具体的分类过程如下:</p>
<ul>
<li>根据给定的距离度量, 在训练集中找出与$x$最邻近的$k$个节点, 将涵盖这些点的$x$的邻域记为$N_k(x)$</li>
<li>在$N_k(x)$中根据分类决策法则决定$x$的类别$y$<br>$$y=argmax\sum_ {  { x_i } \in { N_k(x) }  }  { I(y_i=c_j) } , i=1,2,3…,N; j=1,2,…,K$$<br>其中$I$为指示函数, 即$y_i=c_j$时为1, 否则为0.</li>
</ul>
<p>$k$近邻法的特殊形式是$k=1$的情况, 称为最近邻算法. 对于输入的实例点(特征向量)$x$, 算法将训练集中最接近$x$的点的类作为$x$的类.</p>
<p>值得注意的是, $k$近邻法没有显式的学习过程, 即根据训练集直接得出训练模型.</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>$k$近邻法使用的模型实际上就是对特征空间的分类划分, 模型由三个基本要素——距离度量, $k$值的选择和分类决策决定.</p>
<h3 id="模型意义"><a href="#模型意义" class="headerlink" title="模型意义"></a>模型意义</h3><p>在$k$近邻法中, 但训练集, 距离度量, k值以及分类决策被确定后, 模型空间将被唯一确定, 相当于为空间确定一种划分, 可以理解为涂色, 所以这些色块中每个点的分类都很清楚.</p>
<p><img src="https://github.com/xjywq/picgo/blob/master/k%E8%BF%91%E9%82%BB%E6%B3%95/%E6%A8%A1%E5%9E%8B1.jpg?raw=true" alt="模型1"></p>
<p>在特征空间中, 对每个训练实例点$x_i$, 距离该点比其他点更近的所有点组成一个区域, 叫做单元(cell). 每个训练实例点的类别是确定的, 以上是二位特征空间划分的一个例子.</p>
<h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>特征空间中两个实例点间的距离是两个实例点相似程度的反应. $k$近邻模型的特征空间一般是n维实数向量空间$R^n$. 使用的距离是欧式距离, 但也可以是更加普遍的距离如$L_p$距离($L_p$ distance)或者叫Minkowski距离(Minkowski distance).</p>
<p>令$x_i, x_j \in R^n$, 则$x_i, x_j$的$L_p$距离定义为<br>$$L_p(x_i, x_j)=(\sum_ { l=1 } ^ { n }  { |x_i^ { (l) } -x_j^ { (l) } |^p } )^ { \frac1p } $$<br>这里$p\geq1$. 当$p=2$时, 称为欧式距离(Euclidean distance), 即<br>$$L_2(x_i, x_j)=(\sum_ { l=1 } ^ { n }  { |x_i^ { (l) } -x_j^ { (l) } |^2 } )^ { \frac12 } $$<br>当$p=1$时, 称为曼哈顿距离(Manhattan distance), 即<br>$$L_2(x_i, x_j)=\sum_ { l=1 } ^ { n }  { |x_i^ { (l) } -x_j^ { (l) } | } $$<br>当$p=\infty$时, 它是各个坐标差的最大值, 即<br>$$L_\infty(x_i, x_j)=\max_ { l }  { |x_i^ { (l) } -x_j^ { (l) } | } $$<br>下图是p取不同值时, 与原点的$L_p$距离为1的点的图形.</p>
<p><img src="https://github.com/xjywq/picgo/blob/master/k%E8%BF%91%E9%82%BB%E6%B3%95/Lp1.jpg?raw=true" alt="Lp distence"></p>
<h3 id="k值的选择"><a href="#k值的选择" class="headerlink" title="k值的选择"></a>k值的选择</h3><p>$k$值的选择会对$k$近邻法的结果产生重大影响.<br>如果$k$值比较小, 相当于每个训练实例的作用空间减小了, 那么模型学习的”近似误差”(approximation error)会减小, 只有与输入实例较为接近的训练实例才会对预测起作用. 然而学习的”估计误差”就会减小, 也就更容易受到噪声的影响.</p>
<p>换句话说, $k$值的减小会使模型的复杂度整体上升, 更容易发生过拟合.</p>
<p>当然, $k$值的增大就意味着模型的复杂度下降, 也更容易忽略小片的区域. 如果$k=N$, 模型就简化为相同的空间, 无论输入是什么, 都将得到同样的分类结果, 这是不可取的.</p>
<p>在应用中, $k$一般取一个较小的数值. 通常采用交叉验证的方法来选取最优的$k$值.</p>
<h3 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h3><p>$k$近邻法中的分类决策规则往往采用多数表决, 即由输入实例的$k$个近邻训练实例中的多数表现决定输入实例的类.</p>
<p>多数表决规则(majority voting rule)有如下解释: 如果分类的损失函数为0-1损失函数, 分类函数为<br>$$f:R^n \to \ { c_1,c_2,…,c_K\ } $$<br>那么误分类概率为<br>$$P(Y\not=f(X))=1-P(Y=f(X))$$<br>对给定的$x$, 其最邻近的$k$个训练实例构成集合$N_k(x)$. 如果涵盖$N_k(x)$的区域类别为$c_j$, 那么误分类率是<br>$$\frac1k\sum_ { x_i\in N_k(x) }  { I(y_i\not=c_j) } =1-\frac1k\sum_ { x_i\in N_k(x) }  { I(y_i=c_j) } $$<br>要使误分类率最小, 就要使$\sum_ { x_i\in N_k(x) }  { I(y_i=c_j) } $最大, 所以多数表决规则等价于经验风险最小化.</p>
<h2 id="k邻近法的实现"><a href="#k邻近法的实现" class="headerlink" title="k邻近法的实现"></a>k邻近法的实现</h2><p>$k$邻近法的实现方法有很多, 主要考虑的问题是如何对训练数据进行快速$k$近邻搜索. 这点在特征空间的维数较大及训练数据容量较大时尤其必要.</p>
<p>当然最简单的方法是线性扫描, 但是这种方法并不持久可行.</p>
<p>具体的实现方法此处不多加赘述, 一般使用kd树, 是一种高维空间的树形数据结构, 表示对$k$维超平面的一种划分.</p>
<p>我在另一篇博客中会具体的介绍kd树的建立原理以及实现, <a href="https://xjywq.github.io/2020/9/21/KD-Tree/" target="_blank" rel="noopener">点击此处可以跳转</a>.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>$k$近邻算法是基本且简单的分类回归算法, $k$近邻法的基本做法是: 对给定的训练实例点和输入实例点, 首先确定输入实例点最近的$k$个训练实例点, 然后利用这$k$个训练实例点的分类预测输入实例点的分类.</li>
<li>$k$近邻模型对应特征空间的一种划分, 当训练集, 距离度量, $k$值以及分类决策规则确定后, 其结果唯一确定.</li>
<li>$k$近邻法三要素: 距离度量, $k$值的选取以及分类决策的规则.</li>
<li>$k$近邻法的实现需要考虑如何快速搜索邻近的$k$个点. kd树是高维空间下的二叉树数据结构, 能省去大部分搜索, 从而提升访问速度.</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>KD-Tree</title>
    <url>/2020/9/21/KD-Tree/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>KD 树是一种对 k 维空间中实例点的划分进行储存以便对其进行快速检索的树形数据结构, KD 树为二叉树, 每个分支表示对 k 维空间的一个划分(partition). 构造 KD 树相当于不断用垂直于坐标轴的超平面将 k 维空间划分, 构成一系列的 k 维超矩形区域, KD 树的每一个叶子节点对应一个 k 维的超矩形区域.</p>
<p>本文针对 python, 介绍了 python 构建和使用 KD 树的方法和实现.</p>
<a id="more"></a>

<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><ul>
<li>构造根节点, 使根节点对应于 k 维空间中包含所有实例点的超矩形区域, 通过下面的递归方法, 不断对 k 维空间进行切分.</li>
<li>在超矩形上选一个坐标轴和在此坐标轴上的一个切分点, 确定一个超平面, 这个超平面通过选定的切分点并垂直于选定的坐标轴. 这时, 实例被分到两个子区域.</li>
<li>这个过程一直持续到子区域内没有实例时终止, 在过程中, 将实例保存在相应的节点上.</li>
<li>通常, 选择的训练实例点在选定坐标轴上的中位数为切分点, 这样会得到平衡的 KD 树, 但值得注意的是, 平衡的 KD 树搜索效率未必是最优的.</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>为了方便起见, 我们使用 python 处理数据, 当然 python 中也有很多模块可以直接使用, 比如<code>kd</code>, <code>scipy</code>等等. 当然此处我们选择使用源码实现.</p>
<ul>
<li>首先是对树进行构建, 为此我们需要定义树的节点, 如下:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KD_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elt=None, split=None, LL=None, RR=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        @param: elt Data: 数据点</span></span><br><span class="line"><span class="string">        @param: split number: 划分维度</span></span><br><span class="line"><span class="string">        @param: LL, RR KD_node: 节点的左儿子跟右儿子</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.elt = elt</span><br><span class="line">        self.split = split</span><br><span class="line">        self.left = LL</span><br><span class="line">        self.right = RR</span><br></pre></td></tr></table></figure>

<ul>
<li>然后是对树的生成, 我们选择计算每个维度的方差, 选择其中最大值, 这样虽然在建立 KD 树时会增加生成时间, 但是在搜索时可以节省时间^[另有方法是取一个 Hash 函数, 这样虽然建立时节省了大量时间, 却不能对搜索进行优化, 两种方法各有优势, 可自行选择], 使用递归计算分类的维度后对没个点分类切片^[值得注意的是为了节省空间, 经过构建后 Datalist 会被以一定规则排序], 使用的距离规则为欧拉距离, 即取平方加和再开根号.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createKDTree</span><span class="params">(root, data_list)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: root KD_node: 当前树的根节点</span></span><br><span class="line"><span class="string">    @param: data_list list: 数据点的集合(无序)</span></span><br><span class="line"><span class="string">    @return: root KD_node: 构造的KDTree的树根</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    LEN = len(data_list)</span><br><span class="line">    <span class="keyword">if</span> LEN == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 数据点的维度</span></span><br><span class="line">    dimension = len(data_list[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 方差</span></span><br><span class="line">    max_var = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 最后选择的划分域</span></span><br><span class="line">    split = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(dimension):</span><br><span class="line">        ll = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> data_list:</span><br><span class="line">            ll.append(t[i])</span><br><span class="line">        var = computeVariance(ll)</span><br><span class="line">        <span class="keyword">if</span> var &gt; max_var:</span><br><span class="line">            max_var = var</span><br><span class="line">            split = i</span><br><span class="line">    <span class="comment"># 根据划分域的数据对数据点进行排序</span></span><br><span class="line">    data_list.sort(key=<span class="keyword">lambda</span> x: x[split])</span><br><span class="line">    <span class="comment"># 选择下标为len // 2的点作为分割点</span></span><br><span class="line">    elt = data_list[LEN // <span class="number">2</span>]</span><br><span class="line">    root = KD_node(elt, split)</span><br><span class="line">    root.left = createKDTree(root.left, data_list[<span class="number">0</span>:(LEN // <span class="number">2</span>)])</span><br><span class="line">    root.right = createKDTree(root.right, data_list[(LEN // <span class="number">2</span> + <span class="number">1</span>):LEN])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeVariance</span><span class="params">(arrayList)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: arrayList list: 存放的数据点</span></span><br><span class="line"><span class="string">    @return: variance number: 返回数据点的方差</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> ele <span class="keyword">in</span> arrayList:</span><br><span class="line">        ele = float(ele)</span><br><span class="line">    LEN = float(len(arrayList))</span><br><span class="line">    array = np.array(arrayList)</span><br><span class="line">    sum1 = array.sum()</span><br><span class="line">    array2 = array * array</span><br><span class="line">    sum2 = array2.sum()</span><br><span class="line">    mean = sum1 / LEN</span><br><span class="line">    <span class="comment"># D[X] = E[x^2] - (E[x])^2 使用欧拉距离</span></span><br><span class="line">    variance = sum2 / LEN - mean**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> variance</span><br></pre></td></tr></table></figure>

<ul>
<li>之后便是搜索的定义和使用, 我们定义具体的距离计算公式, 并通过栈寻找最邻近的点, 返回点与其距离.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findNN</span><span class="params">(root, query)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: root KD_node: KDTree的树根</span></span><br><span class="line"><span class="string">    @param: query Data: 查询点</span></span><br><span class="line"><span class="string">    @return: NN,mindist KD_node,number: 返回距离data最近的点NN，同时返回最短距离min_dist</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 初始化为root的节点</span></span><br><span class="line">    NN = root.elt</span><br><span class="line">    min_dist = computeDist(query, NN)</span><br><span class="line">    nodeList = []</span><br><span class="line">    temp_root = root</span><br><span class="line">    <span class="comment"># 二分查找建立路径</span></span><br><span class="line">    <span class="keyword">while</span> temp_root:</span><br><span class="line">        nodeList.append(temp_root)</span><br><span class="line">        dd = computeDist(query, temp_root.elt)</span><br><span class="line">        <span class="keyword">if</span> min_dist &gt; dd:</span><br><span class="line">            NN = temp_root.elt</span><br><span class="line">            min_dist = dd</span><br><span class="line">        <span class="comment"># 当前节点的划分域</span></span><br><span class="line">        ss = temp_root.split</span><br><span class="line">        <span class="keyword">if</span> query[ss] &lt;= temp_root.elt[ss]:</span><br><span class="line">            temp_root = temp_root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp_root = temp_root.right</span><br><span class="line">    <span class="comment"># 回溯查找</span></span><br><span class="line">    <span class="keyword">while</span> nodeList:</span><br><span class="line">        <span class="comment"># 使用list模拟栈，后进先出</span></span><br><span class="line">        back_elt = nodeList.pop()</span><br><span class="line">        ss = back_elt.split</span><br><span class="line">        <span class="comment"># 判断是否需要进入父亲节点的子空间进行搜索</span></span><br><span class="line">        <span class="keyword">if</span> abs(query[ss] - back_elt.elt[ss]) &lt; min_dist:</span><br><span class="line">            <span class="keyword">if</span> query[ss] &lt;= back_elt.elt[ss]:</span><br><span class="line">                temp_root = back_elt.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp_root = back_elt.left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> temp_root:</span><br><span class="line">                nodeList.append(temp_root)</span><br><span class="line">                curDist = computeDist(query, temp_root.elt)</span><br><span class="line">                <span class="keyword">if</span> min_dist &gt; curDist:</span><br><span class="line">                    min_dist = curDist</span><br><span class="line">                    NN = temp_root.elt</span><br><span class="line">    <span class="keyword">return</span> NN, min_dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeDist</span><span class="params">(pt1, pt2)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @function: 计算两个数据点的距离</span></span><br><span class="line"><span class="string">    @param: pt1, pt2 point: 输入的数据点</span></span><br><span class="line"><span class="string">    @return: sum number: pt1和pt2之间的距离</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    sum = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pt1)):</span><br><span class="line">        sum = sum + (pt1[i] - pt2[i]) * (pt1[i] - pt2[i])</span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum)</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>至此, KD 树就搭建完毕了, 下面是一份简单的测试源码和完整代码, 不过目前这个 KD 树只支持寻找最近的节点, 如果有兴趣可以自行修改 findNN 函数, 使其返回包含最近的 k 个节点的列表.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">@Description: KD-Tree:</span></span><br><span class="line"><span class="string">@Date     :2020/09/22 00:24:36</span></span><br><span class="line"><span class="string">@Author      :xjywq</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KD_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elt=None, split=None, LL=None, RR=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        @param: elt Data: 数据点</span></span><br><span class="line"><span class="string">        @param: split number: 划分维度</span></span><br><span class="line"><span class="string">        @param: LL, RR KD_node: 节点的左儿子跟右儿子</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.elt = elt</span><br><span class="line">        self.split = split</span><br><span class="line">        self.left = LL</span><br><span class="line">        self.right = RR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createKDTree</span><span class="params">(root, data_list)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: root KD_node: 当前树的根节点</span></span><br><span class="line"><span class="string">    @param: data_list list: 数据点的集合(无序)</span></span><br><span class="line"><span class="string">    @return: root KD_node: 构造的KDTree的树根</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    LEN = len(data_list)</span><br><span class="line">    <span class="keyword">if</span> LEN == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 数据点的维度</span></span><br><span class="line">    dimension = len(data_list[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 方差</span></span><br><span class="line">    max_var = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 最后选择的划分域</span></span><br><span class="line">    split = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(dimension):</span><br><span class="line">        ll = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> data_list:</span><br><span class="line">            ll.append(t[i])</span><br><span class="line">        var = computeVariance(ll)</span><br><span class="line">        <span class="keyword">if</span> var &gt; max_var:</span><br><span class="line">            max_var = var</span><br><span class="line">            split = i</span><br><span class="line">    <span class="comment"># 根据划分域的数据对数据点进行排序</span></span><br><span class="line">    data_list.sort(key=<span class="keyword">lambda</span> x: x[split])</span><br><span class="line">    <span class="comment"># 选择下标为len / 2的点作为分割点</span></span><br><span class="line">    elt = data_list[LEN // <span class="number">2</span>]</span><br><span class="line">    root = KD_node(elt, split)</span><br><span class="line">    root.left = createKDTree(root.left, data_list[<span class="number">0</span>:(LEN // <span class="number">2</span>)])</span><br><span class="line">    root.right = createKDTree(root.right, data_list[(LEN // <span class="number">2</span> + <span class="number">1</span>):LEN])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeVariance</span><span class="params">(arrayList)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: arrayList list: 存放的数据点</span></span><br><span class="line"><span class="string">    @return: variance number: 返回数据点的方差</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> ele <span class="keyword">in</span> arrayList:</span><br><span class="line">        ele = float(ele)</span><br><span class="line">    LEN = float(len(arrayList))</span><br><span class="line">    array = np.array(arrayList)</span><br><span class="line">    sum1 = array.sum()</span><br><span class="line">    array2 = array * array</span><br><span class="line">    sum2 = array2.sum()</span><br><span class="line">    mean = sum1 / LEN</span><br><span class="line">    <span class="comment">#D[X] = E[x^2] - (E[x])^2</span></span><br><span class="line">    variance = sum2 / LEN - mean**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> variance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findNN</span><span class="params">(root, query)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: root KD_node: KDTree的树根</span></span><br><span class="line"><span class="string">    @param: query Data: 查询点</span></span><br><span class="line"><span class="string">    @return: NN,mindist KD_node,number: 返回距离data最近的点NN，同时返回最短距离min_dist</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 初始化为root的节点</span></span><br><span class="line">    NN = root.elt</span><br><span class="line">    min_dist = computeDist(query, NN)</span><br><span class="line">    nodeList = []</span><br><span class="line">    temp_root = root</span><br><span class="line">    <span class="comment"># 二分查找建立路径</span></span><br><span class="line">    <span class="keyword">while</span> temp_root:</span><br><span class="line">        nodeList.append(temp_root)</span><br><span class="line">        dd = computeDist(query, temp_root.elt)</span><br><span class="line">        <span class="keyword">if</span> min_dist &gt; dd:</span><br><span class="line">            NN = temp_root.elt</span><br><span class="line">            min_dist = dd</span><br><span class="line">        <span class="comment"># 当前节点的划分域</span></span><br><span class="line">        ss = temp_root.split</span><br><span class="line">        <span class="keyword">if</span> query[ss] &lt;= temp_root.elt[ss]:</span><br><span class="line">            temp_root = temp_root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp_root = temp_root.right</span><br><span class="line">    <span class="comment"># 回溯查找</span></span><br><span class="line">    <span class="keyword">while</span> nodeList:</span><br><span class="line">        <span class="comment"># 使用list模拟栈，后进先出</span></span><br><span class="line">        back_elt = nodeList.pop()</span><br><span class="line">        ss = back_elt.split</span><br><span class="line">        <span class="comment"># 判断是否需要进入父亲节点的子空间进行搜索</span></span><br><span class="line">        <span class="keyword">if</span> abs(query[ss] - back_elt.elt[ss]) &lt; min_dist:</span><br><span class="line">            <span class="keyword">if</span> query[ss] &lt;= back_elt.elt[ss]:</span><br><span class="line">                temp_root = back_elt.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp_root = back_elt.left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> temp_root:</span><br><span class="line">                nodeList.append(temp_root)</span><br><span class="line">                curDist = computeDist(query, temp_root.elt)</span><br><span class="line">                <span class="keyword">if</span> min_dist &gt; curDist:</span><br><span class="line">                    min_dist = curDist</span><br><span class="line">                    NN = temp_root.elt</span><br><span class="line">    <span class="keyword">return</span> NN, min_dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeDist</span><span class="params">(pt1, pt2)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @function: 计算两个数据点的距离</span></span><br><span class="line"><span class="string">    @param: pt1, pt2 point: 输入的数据点</span></span><br><span class="line"><span class="string">    @return: sum number: pt1和pt2之间的距离</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    sum = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pt1)):</span><br><span class="line">        sum = sum + (pt1[i] - pt2[i]) * (pt1[i] - pt2[i])</span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = KD_node()</span><br><span class="line">    Data = [[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]] <span class="comment"># 简单的测试代码</span></span><br><span class="line">    Tree = createKDTree(root, Data) <span class="comment"># 建立树</span></span><br><span class="line"></span><br><span class="line">    NN, min_dist = findNN(Tree, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">    print(NN, min_dist)</span><br><span class="line">    NN, min_dist = findNN(Tree, [<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2</span>])</span><br><span class="line">    print(NN, min_dist)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>深度学习</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
</search>

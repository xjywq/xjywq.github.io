<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Avltree</title>
    <url>/2020/7/2/Avltree/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>平衡树是基于二叉查找树的一种数据结构,添加了更加严格的管理制度用以保证树的高度,即<strong>每一个节点的左右子树深度之差</strong>不超过 1.</li>
<li>但是条件可能过于严格,导致插入和删除的操作会导致数据大量的移动.<a id="more"></a>

</li>
</ul>
<h2 id="结构实现"><a href="#结构实现" class="headerlink" title="结构实现"></a>结构实现</h2><ul>
<li>储存方式依旧是二叉树储存,对于每个节点需要添加一个关键字<code>depth</code>用来储存该节点的深度.</li>
<li>对于插入操作,可能会引起深度的变化导致失衡,我们把失衡的节点叫做危机节点,此时需要调整危机节点及周围节点.</li>
<li>对于删除操作,和插入同理.</li>
<li>查找与二叉树相同,此处不在赘述.</li>
</ul>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>选用 C++实现 avl 树的构建.</p>
<h3 id="avl-树的构建"><a href="#avl-树的构建" class="headerlink" title="avl 树的构建"></a>avl 树的构建</h3><ul>
<li>对于节点,需要定义两颗子树,数据部分以及深度 4 个变量.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">avlTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Type content;</span><br><span class="line">        node *left;</span><br><span class="line">        node *right;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h3><ul>
<li>构造函数和析构函数与普通二叉树相同</li>
<li>查找函数和清空函数也完全相同</li>
</ul>
<h3 id="获取树的深度"><a href="#获取树的深度" class="headerlink" title="获取树的深度"></a>获取树的深度</h3><ul>
<li>我们需要创建一个函数更新树的深度, 对于每一个叶子节点, 深度为 1.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_depth</span><span class="params">(Node *node)</span> <span class="comment">// update node's depth</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l_depth = (node-&gt;left == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;left-&gt;depth;</span><br><span class="line">    <span class="keyword">int</span> r_depth = (node-&gt;right == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;right-&gt;depth;</span><br><span class="line">    node-&gt;depth = <span class="number">1</span> + <span class="built_in">std</span>::<span class="built_in">max</span>(l_depth, r_depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同时我们还需要一个函数在后续更方便的获取深度, 或者我们可以使用定义的方式.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_depth</span><span class="params">(<span class="keyword">const</span> Node *node)</span>    <span class="comment">// get_depth</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (node == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define Get_depth(p) ((p==NULL) ? 0 : (((Node *)(p))-&gt;height))</span></span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li>对于一般的插入,我们只需要从下至上修改节点的深度即可</li>
<li>如果遇到节点失衡,一般来说会有四种情况, 我们先假设插入到 <strong>A</strong> 节点左节点的左节点, 如图中 <strong>F</strong> 节点为插入节点:<br><img src="https://raw.githubusercontent.com/xjywq/picgo/master/avltree1.jpg" alt="avltree1"><br>此时需要将危机节点左节点的右子树变成右节点的左子树, 同样是做一次旋转使得 <strong>A</strong> 下放, <strong>B</strong> 上升, 注意 <strong>D</strong> 节点的位置, 旋转结果如下:<br><img src="https://raw.githubusercontent.com/xjywq/picgo/master/avltree2.jpg" alt="avltree2"><br>这种方法我们一般称之为单旋转, 即只需要做一次旋转即可, 如图中插入左节点的左节点, 这种旋转方法被称为 <strong>LL</strong> 方法.<br>同样右节点的右节点插入失衡的调节我们称之为 <strong>RR</strong> 方法.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">avlRotate_LL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *new_root = node-&gt;left;</span><br><span class="line">    node-&gt;left = new_root-&gt;right;</span><br><span class="line">    new_root-&gt;right = node;</span><br><span class="line">    update_depth(node);</span><br><span class="line">    update_depth(new_root);</span><br><span class="line">    <span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于 <strong>RR</strong> 方法, 只需要反过来即可.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">avlRotate_RR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *new_root = node-&gt;right;</span><br><span class="line">    node-&gt;right = new_root-&gt;left;</span><br><span class="line">    new_root-&gt;left = node;</span><br><span class="line">    update_depth(node);</span><br><span class="line">    update_depth(new_root);</span><br><span class="line">    <span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果插入节点在危机节点左节点的右节点, 用 <strong>LL</strong> 方法则会出现不平衡.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xjywq/picgo/master/avltree3.jpg" alt="avltree3"></p>
<p>所以我们需要先对 <strong>A</strong> 的左节点 <strong>B</strong> 进行一次 <strong>RR</strong> 旋转, 使 <strong>A</strong> 转变为单旋转的情况, 然后再对 <strong>A</strong> 进行 <strong>LL</strong> 旋转得到正确结果.</p>
<p><img src="https://raw.githubusercontent.com/xjywq/picgo/master/avltree4.jpg" alt="avltree4"><br><img src="https://raw.githubusercontent.com/xjywq/picgo/master/avltree5.jpg" alt="avltree5"></p>
<p>这种方法用到了两次旋转, 所以被称为双旋转, 或者 <strong>LR</strong> 方法.<br>同样我们也可以类似得出 <strong>RL</strong> 方法.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">avlRotate_LR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    avlRotate_RR(node-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> avlRotate_LL(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">avlRotate_RL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    avlRotate_LL(node-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> avlRotate_RR(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是插入函数的具体实现, 由于需要用到递归, 所以显然需要一个包装函数. 直接上代码, 解释都在代码中.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> new_content)</span>    <span class="comment">// 包装函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_node;</span><br><span class="line">        new_node = <span class="keyword">new</span> Node(new_content);</span><br><span class="line">        Root = Insert(Root, new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">Insert</span><span class="params">(Node *root, Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;content == node-&gt;content) <span class="comment">// 找到目标节点, 递归终止</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &gt; node-&gt;content) <span class="comment">// 目标节点在左节点中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = Insert(root-&gt;left, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>) <span class="comment">// 出现不平衡了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left-&gt;content &gt; node-&gt;content) <span class="comment">// 单旋转情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left-&gt;content &lt; node-&gt;content) <span class="comment">// 双旋转情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; node-&gt;content) <span class="comment">// 目标节点在右节点中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = Insert(root-&gt;right, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>) <span class="comment">// 同上</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right-&gt;content &gt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right-&gt;content &lt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        update_depth(root); <span class="comment">// 更新节点深度</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除节点的基本思路同插入相同, 当插入节点为叶子节点或者只有一个子树时, 只需要重新更新节点深度, 并做旋转更新即可. 但是当插入节点为非叶子节点时, 需要寻找叶子节点中的代替节点, 将代替节点替换为当前节点, 从而将问题转变为删除叶子节点.</p>
<p>我所采用的方法是寻找左子树中最大的节点或者右子树中最小的节点(视左右子树的高度为定), 当然也有方法是全部使用一种节点, 这样最多多做两次旋转, 并没有很大的差距.</p>
<p>当然, 删除函数也需要做一次包装, 我希望删除函数返回一个 <strong>bool</strong> 值, 如果删除值在树中则返回<code>True</code>, 否则返回<code>False</code>, 这时就需要用到查找函数.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Type &amp;n)</span> <span class="comment">// 包装函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(n) == <span class="literal">NULL</span>) <span class="comment">// 查找失败返回False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Node *node;</span><br><span class="line">        node = <span class="keyword">new</span> Node(n);</span><br><span class="line">        Root = DELETE(Root, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">DELETE</span><span class="params">(Node *root, Node *del)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || del == <span class="literal">NULL</span>) <span class="comment">// 防止错误, 此处并无作用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;content &gt; del-&gt;content) <span class="comment">// 删除节点在左子树中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = DELETE(root-&gt;left, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>) <span class="comment">// 出现危机节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; del-&gt;content) <span class="comment">// 删除节点在右子树中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = DELETE(root-&gt;right, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 当前节点就是删除节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) <span class="comment">// 如果当前节点有左右子树, 即是非叶子节点, 那么寻找最深的临近节点做替换</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right) &gt; Get_depth(root-&gt;left)) <span class="comment">// 右子树深度大</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node *right = root-&gt;right;</span><br><span class="line">                    <span class="keyword">while</span> (right-&gt;left)</span><br><span class="line">                        right = right-&gt;left; <span class="comment">// 循环获取最深的节点</span></span><br><span class="line">                    root-&gt;content = right-&gt;content;</span><br><span class="line">                    root-&gt;right = DELETE(root-&gt;right, root); <span class="comment">// 从右子树中删除该叶子节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node *left = root-&gt;left;</span><br><span class="line">                    <span class="keyword">while</span> (left-&gt;right)</span><br><span class="line">                        left = left-&gt;right;</span><br><span class="line">                    root-&gt;content = left-&gt;content;</span><br><span class="line">                    root-&gt;left = DELETE(root-&gt;left, root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 当前节点只有一个子树或者是叶子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node *tmp = root;</span><br><span class="line">                root = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(tmp); <span class="comment">// 释放空间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update_depth(root); <span class="comment">// 更新深度</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AvlTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Type content;</span><br><span class="line">        Node *left;</span><br><span class="line">        Node *right;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line">        Node(<span class="keyword">const</span> Type &amp;c) : content(c), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), depth(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_depth</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> l_depth = (node-&gt;left == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;left-&gt;depth;</span><br><span class="line">        <span class="keyword">int</span> r_depth = (node-&gt;right == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;right-&gt;depth;</span><br><span class="line">        node-&gt;depth = <span class="number">1</span> + <span class="built_in">std</span>::<span class="built_in">max</span>(l_depth, r_depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Get_depth</span><span class="params">(<span class="keyword">const</span> Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> node-&gt;depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_LL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_root = node-&gt;left;</span><br><span class="line">        node-&gt;left = new_root-&gt;right;</span><br><span class="line">        new_root-&gt;right = node;</span><br><span class="line">        update_depth(node);</span><br><span class="line">        update_depth(new_root);</span><br><span class="line">        <span class="keyword">return</span> new_root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_RR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_root = node-&gt;right;</span><br><span class="line">        node-&gt;right = new_root-&gt;left;</span><br><span class="line">        new_root-&gt;left = node;</span><br><span class="line">        update_depth(node);</span><br><span class="line">        update_depth(new_root);</span><br><span class="line">        <span class="keyword">return</span> new_root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_LR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        avlRotate_RR(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> avlRotate_LL(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_RL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        avlRotate_LL(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> avlRotate_RR(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OutPut</span><span class="params">(<span class="keyword">const</span> Node *node)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        OutPut(node-&gt;left);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; node-&gt;content &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        OutPut(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">Insert</span><span class="params">(Node *root, Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;content == node-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &gt; node-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = Insert(root-&gt;left, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left-&gt;content &gt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left-&gt;content &lt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; node-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = Insert(root-&gt;right, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right-&gt;content &gt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right-&gt;content &lt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        update_depth(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">DELETE</span><span class="params">(Node *root, Node *del)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || del == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;content &gt; del-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = DELETE(root-&gt;left, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; del-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = DELETE(root-&gt;right, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right) &gt; Get_depth(root-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    Node *right = root-&gt;right;</span><br><span class="line">                    <span class="keyword">while</span> (right-&gt;left)</span><br><span class="line">                        right = right-&gt;left;</span><br><span class="line">                    root-&gt;content = right-&gt;content;</span><br><span class="line">                    root-&gt;right = DELETE(root-&gt;right, root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node *left = root-&gt;left;</span><br><span class="line">                    <span class="keyword">while</span> (left-&gt;right)</span><br><span class="line">                        left = left-&gt;right;</span><br><span class="line">                    root-&gt;content = left-&gt;content;</span><br><span class="line">                    root-&gt;left = DELETE(root-&gt;left, root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node *tmp = root;</span><br><span class="line">                root = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update_depth(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            Clear(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            Clear(node-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Node *Root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AvlTree() : Root(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        OutPut(Root);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> new_content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_node;</span><br><span class="line">        new_node = <span class="keyword">new</span> Node(new_content);</span><br><span class="line">        Root = Insert(Root, new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">find</span><span class="params">(<span class="keyword">const</span> Type &amp;n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *root = Root;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span> &amp;&amp; root-&gt;content != n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;content &gt; n)</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; n)</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Type &amp;n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(n) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Node *node;</span><br><span class="line">        node = <span class="keyword">new</span> Node(n);</span><br><span class="line">        Root = DELETE(Root, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Clear(Root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AvlTree&lt;<span class="keyword">int</span>&gt; avl;</span><br><span class="line">    avl.insert(<span class="number">1</span>);</span><br><span class="line">    avl.insert(<span class="number">2</span>);</span><br><span class="line">    avl.insert(<span class="number">3</span>);</span><br><span class="line">    avl.insert(<span class="number">4</span>);</span><br><span class="line">    avl.insert(<span class="number">5</span>);</span><br><span class="line">    avl.insert(<span class="number">6</span>);</span><br><span class="line">    avl.insert(<span class="number">7</span>);</span><br><span class="line">    avl.insert(<span class="number">8</span>);</span><br><span class="line">    avl.<span class="built_in">print</span>();</span><br><span class="line">    avl.Delete(<span class="number">4</span>);</span><br><span class="line">    avl.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">bool</span> a = avl.Delete(<span class="number">12</span>);</span><br><span class="line">    avl.<span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    avl.<span class="built_in">clear</span>();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有疑问请加 QQ 联系我.</p>
]]></content>
      <categories>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/7/1/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown_case</title>
    <url>/2020/7/2/markdown-case/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单的 markdown 编辑实例</p>
<a id="more"></a>

<h2 id="1-语言介绍"><a href="#1-语言介绍" class="headerlink" title="1. 语言介绍"></a>1. 语言介绍</h2><p><strong>Markdown</strong> 是一种可以使用普通文本编辑器编写的标记语言, 通过简单的标记语法, 它可以使普通文本内容具有一定的格式.</p>
<h2 id="2-兼容-HTML"><a href="#2-兼容-HTML" class="headerlink" title="2. 兼容 HTML"></a>2. 兼容 HTML</h2><p>Markdown 语法的目标是:成为一种适用于网络的书写语言.</p>
<h2 id="3-标题"><a href="#3-标题" class="headerlink" title="3. 标题"></a>3. 标题</h2><ul>
<li>使用<code>#</code>标记标题, 最多可以有 6 级标题.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>-</code>或者<code>=</code>标记标题, 仅支持二级标题.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>-</code>, <code>=</code>或者<code>*</code>可以指定无序标签</li>
</ul>
<ol>
<li>直接使用数字可以形成有序标签, 值得注意的是, 数字显示的标签与输入的数字无关<ol>
<li>另外, 使用制表符也可以轻易的形成嵌套结构</li>
</ol>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>使用<span class="code">`-`</span>, <span class="code">`=`</span>或者<span class="code">`*`</span>可以指定无序标签</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>直接使用数字可以形成有序标签, 值得注意的是, 数字显示的标签与输入的数字无关</span><br><span class="line"><span class="bullet">   1. </span>另外, 使用制表符也可以轻易的形成嵌套结构</span><br></pre></td></tr></table></figure>

<h2 id="4-段落"><a href="#4-段落" class="headerlink" title="4. 段落"></a>4. 段落</h2><p>markdown 没有特殊的段落格式要求, 主要因为 markdown 是基于文本构建, 所以不能让文本编辑过于复杂.<br>只需要在段落的最后添加两个空格或者留下一段空行即可换行.</p>
<h2 id="5-字体"><a href="#5-字体" class="headerlink" title="5. 字体"></a>5. 字体</h2><p>markdown 支持以下字体:</p>
<ul>
<li><em>斜体文本</em>.</li>
<li><em>斜体文本</em>.</li>
<li><strong>粗体文本</strong>.</li>
<li><strong>粗体文本</strong>.</li>
<li><strong><em>粗斜体文本</em></strong>.</li>
<li><strong><em>粗斜体文本</em></strong>.</li>
<li><del>删除文本</del>.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">_斜体文本_</span>.</span><br><span class="line"><span class="emphasis">_斜体文本_</span>.</span><br><span class="line"><span class="strong">**粗体文本**</span>.</span><br><span class="line"><span class="strong">**粗体文本**</span>.</span><br><span class="line"><span class="strong">**_粗斜体文本_*</span>*.</span><br><span class="line"><span class="strong">**_粗斜体文本_*</span>*.</span><br><span class="line">~~删除文本~~.</span><br></pre></td></tr></table></figure>

<h2 id="6-HTML-标签在-markdown-中的使用"><a href="#6-HTML-标签在-markdown-中的使用" class="headerlink" title="6. HTML 标签在 markdown 中的使用"></a>6. HTML 标签在 markdown 中的使用</h2><p>HTML 标签在 markdown 渲染时会自动转化.</p>
<ul>
<li>我们可以<mark>高亮文字</mark>.</li>
<li>可以<ins>添加文字下划线</ins>.</li>
<li>可以用另一种方法实现<del>删除线</del>.</li>
<li>或者可以<font color="red">修改字体颜色</font>.</li>
<li>为<ruby>生僻<rt>shēng pì</rt></ruby>字添加注音.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>我们可以<span class="xml"><span class="tag">&lt;<span class="name">mark</span>&gt;</span></span>高亮文字<span class="xml"><span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>可以<span class="xml"><span class="tag">&lt;<span class="name">ins</span>&gt;</span></span>添加文字下划线<span class="xml"><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>可以用另一种方法实现<span class="xml"><span class="tag">&lt;<span class="name">del</span>&gt;</span></span>删除线<span class="xml"><span class="tag">&lt;/<span class="name">del</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>或者可以<span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span></span>修改字体颜色等等<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>为<span class="xml"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span>生僻<span class="xml"><span class="tag">&lt;<span class="name">rt</span>&gt;</span></span>shēng pì<span class="xml"><span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span>字添加注音.</span><br></pre></td></tr></table></figure>

<h2 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7. 分割线"></a>7. 分割线</h2><p>实现原理很简单, 三个(或以上)连续的<code>-</code>或者<code>*</code>即可.</p>
<hr>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="7-注释"><a href="#7-注释" class="headerlink" title="7. 注释"></a>7. 注释</h2><p>markdown 对于文本注释的支持非常好[^非常好].<br>[^非常好]:所有的标注会自动编号并放在文章末尾</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">markdown 对于文本注释的支持非常好[^非常好].</span><br><span class="line">[<span class="symbol">^非常好</span>]:<span class="link">所有的标注会自动编号并放在文章末尾</span></span><br></pre></td></tr></table></figure>

<h2 id="8-代码区"><a href="#8-代码区" class="headerlink" title="8. 代码区"></a>8. 代码区</h2><p>使用 ` 符号可以形成行内代码词, 而三个 ` 则会形成代码块.<br>或者直接使用制表符(4 个空格)加在每行前面可以达到同样代码块的效果.</p>
<h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9. 表格"></a>9. 表格</h2><p>使用<code>|</code>符号来制作表格, 使用<code>:</code>来提示对齐方向.</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="center">班级</th>
<th align="right">成绩</th>
</tr>
</thead>
<tbody><tr>
<td align="left">xjywq</td>
<td align="center">1</td>
<td align="right">100</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 姓名  | 班级 | 成绩 |</span><br><span class="line">| :---- | :--: | ---: |</span><br><span class="line">| xjywq |  1   |  100 |</span><br></pre></td></tr></table></figure>

<h2 id="10-链接"><a href="#10-链接" class="headerlink" title="10. 链接"></a>10. 链接</h2><ul>
<li>可以使用<code>[]</code>符号管理显示的链接名称, <code>()</code>符号管理链接方向, <code>&quot;&quot;</code>符号管理链接标题, 如<a href="www.baidu.com" title="百度搜索">百度</a>.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">www.baidu.com "百度搜索"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>或者可以用<code>&lt;&gt;</code>显式指定链接, 如<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.baidu.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>或者可以使用注释类型, 将 7 和 10 结合, 如<a href="www.baidu.com" title="百度搜索">百度</a>, 但是注释之间必须留一个空行.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>][<span class="symbol">baidu</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">baidu</span>]: <span class="link">www.baidu.com "百度搜索"</span></span><br></pre></td></tr></table></figure>

<h2 id="11-图片"><a href="#11-图片" class="headerlink" title="11. 图片"></a>11. 图片</h2><ul>
<li>使用链接的格式, 但是在开头加上<code>!</code>, 链接地址使用本地路径(支持绝对路径与相对路径), 在 hexo 上无法正确显示, 需要文件的相对位置, 且位置起始地址为 sourse 文件夹下.</li>
</ul>
<p><img src="/picture/markdown-case/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg" alt="麻衣学姐"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">普通 markdown 文件中:</span><br><span class="line">![<span class="string">麻衣学姐</span>](<span class="link">/markdown-case/麻衣学姐.jpg</span>)</span><br><span class="line"></span><br><span class="line">在 hexo 中则是:</span><br><span class="line">![<span class="string">麻衣学姐</span>](<span class="link">/picture/markdown-case/麻衣学姐.jpg</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用在线图床, 同上</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xjywq/picgo/master/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg" alt="麻衣学姐" title="这是我的老婆"></p>
<ul>
<li>使用 HTML 语法</li>
</ul>
<img src="https://raw.githubusercontent.com/xjywq/picgo/master/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg" alt = "麻衣学姐">

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hhttps://raw.githubusercontent.com/xjywq/picgo/master/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg"</span> <span class="attr">alt</span> = <span class="string">"麻衣学姐"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="13-公式"><a href="#13-公式" class="headerlink" title="13. 公式"></a>13. 公式</h2><ul>
<li>markdown 可以通过简单的语法插入公式, 首先是通过<code>$</code>符号, 如$\frac{1+2}{2}=1.5$, 或者另一起一行作为独立公式$$\sum_{i=0}^n{\frac 1 n}=\infty$$</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内公式</span><br><span class="line">$\frac&#123;1+2&#125;&#123;2&#125;=1.5$</span><br><span class="line"></span><br><span class="line">单独公式</span><br><span class="line">$$\sum_&#123;i=0&#125;^n&#123;\frac 1 n&#125;=\infty$$</span><br></pre></td></tr></table></figure>

<ul>
<li><p>或者使用<a href="https://www.codecogs.com/eqnedit.php" target="_blank" rel="noopener">在线公式编辑器</a>, 可以复制得到的图像或者借助于下方的 HTML 方法</p>
</li>
<li><p>H 也可以直接手动使用 HTML 方法, 借助<a href="http://chart.googleapis.com/chart" target="_blank" rel="noopener">google chart</a>或者其他</p>
</li>
</ul>
<img src="http://chart.googleapis.com/chart?cht=tx&chl= \sum_{i=0}^n{\frac 1 n}=\infty" style="border:none;">

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">谷歌服务器</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://chart.googleapis.com/chart?cht=tx&amp;chl= \sum_&#123;i=0&#125;^n&#123;\frac 1 n&#125;=\infty"</span> <span class="attr">style</span>=<span class="string">"border:none;"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在这里贴一下一位大佬的<a href="https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan" target="_blank" rel="noopener">LaTeX 数学公式大全</a>, 很好用</p>
<h2 id="14-mermaid-使用"><a href="#14-mermaid-使用" class="headerlink" title="14. mermaid 使用"></a>14. mermaid 使用</h2><ul>
<li>部分 markdown 编辑器支持 mermaid 的流程图渲染等等, 可惜 hexo 并不支持这点(暂时没有装插件的打算, 可能以后会考虑)</li>
<li>可以看看 CSDN 上大佬发的 mermaid<a href="https://blog.csdn.net/weixin_33901641/article/details/90303528?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase" target="_blank" rel="noopener">实用教程</a></li>
</ul>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>文本编辑</tag>
      </tags>
  </entry>
  <entry>
    <title>catch_the_cat</title>
    <url>/2020/9/9/catch_the_cat/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在小猫周围建墙, 阻止它逃走吧, 不要让它跑到周围的地方哦<br><img src="https://raw.githubusercontent.com/xjywq/picgo/master/catch_the_cat.jpg" alt="demo"></p>
<a id="more"></a>

<h2 id="地址链接"><a href="#地址链接" class="headerlink" title="地址链接"></a>地址链接</h2><p><a href="https://xjywq.github.io/catch_the_cat" target="_blank" rel="noopener" title="小游戏">小游戏地址</a></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在hexo的resource文件夹下建立catch_the_cat文件夹, 将js文件放在里面, 通过链接跳转即可</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">小游戏地址</span>](<span class="link">https://xjywq.github.io/catch_the_cat "小游戏"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>有机会我自己用js写一个五子棋试试, 在做了在做了.jpg</p>
]]></content>
      <tags>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>k近邻法</title>
    <url>/2020/9/9/k%E8%BF%91%E9%82%BB%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
</search>

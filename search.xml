<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Avltree</title>
    <url>/2020/7/2/Avltree/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>平衡树是基于二叉查找树的一种数据结构,添加了更加严格的管理制度用以保证树的高度,即<strong>每一个节点的左右子树深度之差</strong>不超过 1.</li>
<li>但是条件可能过于严格,导致插入和删除的操作会导致数据大量的移动.</li>
</ul>
<a id="more"></a>

<h2 id="结构实现"><a href="#结构实现" class="headerlink" title="结构实现"></a>结构实现</h2><ul>
<li>储存方式依旧是二叉树储存,对于每个节点需要添加一个关键字<code>depth</code>用来储存该节点的深度.</li>
<li>对于插入操作,可能会引起深度的变化导致失衡,我们把失衡的节点叫做危机节点,此时需要调整危机节点及周围节点.</li>
<li>对于删除操作,和插入同理.</li>
<li>查找与二叉树相同,此处不在赘述.</li>
</ul>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>选用 C++实现 avl 树的构建.</p>
<h3 id="avl-树的构建"><a href="#avl-树的构建" class="headerlink" title="avl 树的构建"></a>avl 树的构建</h3><ul>
<li>对于节点,需要定义两颗子树,数据部分以及深度 4 个变量.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">avlTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Type content;</span><br><span class="line">        node *left;</span><br><span class="line">        node *right;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h3><ul>
<li>构造函数和析构函数与普通二叉树相同</li>
<li>查找函数和清空函数也完全相同</li>
</ul>
<h3 id="获取树的深度"><a href="#获取树的深度" class="headerlink" title="获取树的深度"></a>获取树的深度</h3><ul>
<li>我们需要创建一个函数更新树的深度, 对于每一个叶子节点, 深度为 1.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_depth</span><span class="params">(Node *node)</span> <span class="comment">// update node's depth</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l_depth = (node-&gt;left == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;left-&gt;depth;</span><br><span class="line">    <span class="keyword">int</span> r_depth = (node-&gt;right == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;right-&gt;depth;</span><br><span class="line">    node-&gt;depth = <span class="number">1</span> + <span class="built_in">std</span>::<span class="built_in">max</span>(l_depth, r_depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同时我们还需要一个函数在后续更方便的获取深度, 或者我们可以使用定义的方式.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get_depth</span><span class="params">(<span class="keyword">const</span> Node *node)</span>    <span class="comment">// get_depth</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (node == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define Get_depth(p) ((p==NULL) ? 0 : (((Node *)(p))-&gt;height))</span></span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li>对于一般的插入,我们只需要从下至上修改节点的深度即可</li>
<li>如果遇到节点失衡,一般来说会有四种情况, 我们先假设插入到 <strong>A</strong> 节点左节点的左节点, 如图中 <strong>F</strong> 节点为插入节点:<br><img src="/picture/Avltree/avltree1.jpg" alt="avltree1"><br>此时需要将危机节点左节点的右子树变成右节点的左子树, 同样是做一次旋转使得 <strong>A</strong> 下放, <strong>B</strong> 上升, 注意 <strong>D</strong> 节点的位置, 旋转结果如下:<br><img src="/picture/Avltree/avltree2.jpg" alt="avltree2"><br>这种方法我们一般称之为单旋转, 即只需要做一次旋转即可, 如图中插入左节点的左节点, 这种旋转方法被称为 <strong>LL</strong> 方法.<br>同样右节点的右节点插入失衡的调节我们称之为 <strong>RR</strong> 方法.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">avlRotate_LL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *new_root = node-&gt;left;</span><br><span class="line">    node-&gt;left = new_root-&gt;right;</span><br><span class="line">    new_root-&gt;right = node;</span><br><span class="line">    update_depth(node);</span><br><span class="line">    update_depth(new_root);</span><br><span class="line">    <span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于 <strong>RR</strong> 方法, 只需要反过来即可.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">avlRotate_RR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *new_root = node-&gt;right;</span><br><span class="line">    node-&gt;right = new_root-&gt;left;</span><br><span class="line">    new_root-&gt;left = node;</span><br><span class="line">    update_depth(node);</span><br><span class="line">    update_depth(new_root);</span><br><span class="line">    <span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果插入节点在危机节点左节点的右节点, 用 <strong>LL</strong> 方法则会出现不平衡.</li>
</ul>
<p><img src="/picture/Avltree/avltree3.jpg" alt="avltree3"></p>
<p>所以我们需要先对 <strong>A</strong> 的左节点 <strong>B</strong> 进行一次 <strong>RR</strong> 旋转, 使 <strong>A</strong> 转变为单旋转的情况, 然后再对 <strong>A</strong> 进行 <strong>LL</strong> 旋转得到正确结果.</p>
<p><img src="/picture/Avltree/avltree4.jpg" alt="avltree4"><br><img src="/picture/Avltree/avltree5.jpg" alt="avltree5"></p>
<p>这种方法用到了两次旋转, 所以被称为双旋转, 或者 <strong>LR</strong> 方法.<br>同样我们也可以类似得出 <strong>RL</strong> 方法.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">avlRotate_LR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    avlRotate_RR(node-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> avlRotate_LL(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">avlRotate_RL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    avlRotate_LL(node-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> avlRotate_RR(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是插入函数的具体实现, 由于需要用到递归, 所以显然需要一个包装函数. 直接上代码, 解释都在代码中.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> new_content)</span>    <span class="comment">// 包装函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_node;</span><br><span class="line">        new_node = <span class="keyword">new</span> Node(new_content);</span><br><span class="line">        Root = Insert(Root, new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">Insert</span><span class="params">(Node *root, Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;content == node-&gt;content) <span class="comment">// 找到目标节点, 递归终止</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &gt; node-&gt;content) <span class="comment">// 目标节点在左节点中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = Insert(root-&gt;left, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>) <span class="comment">// 出现不平衡了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left-&gt;content &gt; node-&gt;content) <span class="comment">// 单旋转情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left-&gt;content &lt; node-&gt;content) <span class="comment">// 双旋转情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; node-&gt;content) <span class="comment">// 目标节点在右节点中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = Insert(root-&gt;right, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>) <span class="comment">// 同上</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right-&gt;content &gt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right-&gt;content &lt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        update_depth(root); <span class="comment">// 更新节点深度</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除节点的基本思路同插入相同, 当插入节点为叶子节点或者只有一个子树时, 只需要重新更新节点深度, 并做旋转更新即可. 但是当插入节点为非叶子节点时, 需要寻找叶子节点中的代替节点, 将代替节点替换为当前节点, 从而将问题转变为删除叶子节点.</p>
<p>我所采用的方法是寻找左子树中最大的节点或者右子树中最小的节点(视左右子树的高度为定), 当然也有方法是全部使用一种节点, 这样最多多做两次旋转, 并没有很大的差距.</p>
<p>当然, 删除函数也需要做一次包装, 我希望删除函数返回一个 <strong>bool</strong> 值, 如果删除值在树中则返回<code>True</code>, 否则返回<code>False</code>, 这时就需要用到查找函数.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Type &amp;n)</span> <span class="comment">// 包装函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(n) == <span class="literal">NULL</span>) <span class="comment">// 查找失败返回False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Node *node;</span><br><span class="line">        node = <span class="keyword">new</span> Node(n);</span><br><span class="line">        Root = DELETE(Root, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">DELETE</span><span class="params">(Node *root, Node *del)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || del == <span class="literal">NULL</span>) <span class="comment">// 防止错误, 此处并无作用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;content &gt; del-&gt;content) <span class="comment">// 删除节点在左子树中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = DELETE(root-&gt;left, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>) <span class="comment">// 出现危机节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; del-&gt;content) <span class="comment">// 删除节点在右子树中</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = DELETE(root-&gt;right, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 当前节点就是删除节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) <span class="comment">// 如果当前节点有左右子树, 即是非叶子节点, 那么寻找最深的临近节点做替换</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right) &gt; Get_depth(root-&gt;left)) <span class="comment">// 右子树深度大</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node *right = root-&gt;right;</span><br><span class="line">                    <span class="keyword">while</span> (right-&gt;left)</span><br><span class="line">                        right = right-&gt;left; <span class="comment">// 循环获取最深的节点</span></span><br><span class="line">                    root-&gt;content = right-&gt;content;</span><br><span class="line">                    root-&gt;right = DELETE(root-&gt;right, root); <span class="comment">// 从右子树中删除该叶子节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node *left = root-&gt;left;</span><br><span class="line">                    <span class="keyword">while</span> (left-&gt;right)</span><br><span class="line">                        left = left-&gt;right;</span><br><span class="line">                    root-&gt;content = left-&gt;content;</span><br><span class="line">                    root-&gt;left = DELETE(root-&gt;left, root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 当前节点只有一个子树或者是叶子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node *tmp = root;</span><br><span class="line">                root = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(tmp); <span class="comment">// 释放空间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update_depth(root); <span class="comment">// 更新深度</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AvlTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Type content;</span><br><span class="line">        Node *left;</span><br><span class="line">        Node *right;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line">        Node(<span class="keyword">const</span> Type &amp;c) : content(c), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), depth(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_depth</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> l_depth = (node-&gt;left == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;left-&gt;depth;</span><br><span class="line">        <span class="keyword">int</span> r_depth = (node-&gt;right == <span class="literal">NULL</span>) ? <span class="number">0</span> : node-&gt;right-&gt;depth;</span><br><span class="line">        node-&gt;depth = <span class="number">1</span> + <span class="built_in">std</span>::<span class="built_in">max</span>(l_depth, r_depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Get_depth</span><span class="params">(<span class="keyword">const</span> Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> node-&gt;depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_LL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_root = node-&gt;left;</span><br><span class="line">        node-&gt;left = new_root-&gt;right;</span><br><span class="line">        new_root-&gt;right = node;</span><br><span class="line">        update_depth(node);</span><br><span class="line">        update_depth(new_root);</span><br><span class="line">        <span class="keyword">return</span> new_root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_RR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_root = node-&gt;right;</span><br><span class="line">        node-&gt;right = new_root-&gt;left;</span><br><span class="line">        new_root-&gt;left = node;</span><br><span class="line">        update_depth(node);</span><br><span class="line">        update_depth(new_root);</span><br><span class="line">        <span class="keyword">return</span> new_root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_LR</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        avlRotate_RR(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> avlRotate_LL(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">avlRotate_RL</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        avlRotate_LL(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> avlRotate_RR(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OutPut</span><span class="params">(<span class="keyword">const</span> Node *node)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        OutPut(node-&gt;left);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; node-&gt;content &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        OutPut(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">Insert</span><span class="params">(Node *root, Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;content == node-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &gt; node-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = Insert(root-&gt;left, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left-&gt;content &gt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left-&gt;content &lt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; node-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = Insert(root-&gt;right, node);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right-&gt;content &gt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right-&gt;content &lt; node-&gt;content)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        update_depth(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">DELETE</span><span class="params">(Node *root, Node *del)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || del == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;content &gt; del-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = DELETE(root-&gt;left, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;right) - Get_depth(root-&gt;left) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_RL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; del-&gt;content)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = DELETE(root-&gt;right, del);</span><br><span class="line">            <span class="keyword">if</span> (Get_depth(root-&gt;left) - Get_depth(root-&gt;right) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right-&gt;right) &gt; Get_depth(root-&gt;right-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LR(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    root = avlRotate_LL(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Get_depth(root-&gt;right) &gt; Get_depth(root-&gt;left))</span><br><span class="line">                &#123;</span><br><span class="line">                    Node *right = root-&gt;right;</span><br><span class="line">                    <span class="keyword">while</span> (right-&gt;left)</span><br><span class="line">                        right = right-&gt;left;</span><br><span class="line">                    root-&gt;content = right-&gt;content;</span><br><span class="line">                    root-&gt;right = DELETE(root-&gt;right, root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node *left = root-&gt;left;</span><br><span class="line">                    <span class="keyword">while</span> (left-&gt;right)</span><br><span class="line">                        left = left-&gt;right;</span><br><span class="line">                    root-&gt;content = left-&gt;content;</span><br><span class="line">                    root-&gt;left = DELETE(root-&gt;left, root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node *tmp = root;</span><br><span class="line">                root = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update_depth(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(Node *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            Clear(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            Clear(node-&gt;right);</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Node *Root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AvlTree() : Root(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        OutPut(Root);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> new_content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *new_node;</span><br><span class="line">        new_node = <span class="keyword">new</span> Node(new_content);</span><br><span class="line">        Root = Insert(Root, new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">find</span><span class="params">(<span class="keyword">const</span> Type &amp;n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *root = Root;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span> &amp;&amp; root-&gt;content != n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;content &gt; n)</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;content &lt; n)</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> Type &amp;n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(n) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Node *node;</span><br><span class="line">        node = <span class="keyword">new</span> Node(n);</span><br><span class="line">        Root = DELETE(Root, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Clear(Root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AvlTree&lt;<span class="keyword">int</span>&gt; avl;</span><br><span class="line">    avl.insert(<span class="number">1</span>);</span><br><span class="line">    avl.insert(<span class="number">2</span>);</span><br><span class="line">    avl.insert(<span class="number">3</span>);</span><br><span class="line">    avl.insert(<span class="number">4</span>);</span><br><span class="line">    avl.insert(<span class="number">5</span>);</span><br><span class="line">    avl.insert(<span class="number">6</span>);</span><br><span class="line">    avl.insert(<span class="number">7</span>);</span><br><span class="line">    avl.insert(<span class="number">8</span>);</span><br><span class="line">    avl.<span class="built_in">print</span>();</span><br><span class="line">    avl.Delete(<span class="number">4</span>);</span><br><span class="line">    avl.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">bool</span> a = avl.Delete(<span class="number">12</span>);</span><br><span class="line">    avl.<span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    avl.<span class="built_in">clear</span>();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有疑问请加 QQ 联系我.</p>
]]></content>
      <categories>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/7/1/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown_case</title>
    <url>/2020/7/2/markdown-case/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单的 markdown 编辑实例</p>
<a id="more"></a>

<h2 id="1-语言介绍"><a href="#1-语言介绍" class="headerlink" title="1. 语言介绍"></a>1. 语言介绍</h2><p><strong>Markdown</strong> 是一种可以使用普通文本编辑器编写的标记语言, 通过简单的标记语法, 它可以使普通文本内容具有一定的格式.</p>
<h2 id="2-兼容-HTML"><a href="#2-兼容-HTML" class="headerlink" title="2. 兼容 HTML"></a>2. 兼容 HTML</h2><p>Markdown 语法的目标是:成为一种适用于网络的书写语言.</p>
<h2 id="3-标题"><a href="#3-标题" class="headerlink" title="3. 标题"></a>3. 标题</h2><ul>
<li>使用<code>#</code>标记标题, 最多可以有 6 级标题.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>-</code>或者<code>=</code>标记标题, 仅支持二级标题.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>-</code>, <code>=</code>或者<code>*</code>可以指定无序标签</li>
</ul>
<ol>
<li>直接使用数字可以形成有序标签, 值得注意的是, 数字显示的标签与输入的数字无关<ol>
<li>另外, 使用制表符也可以轻易的形成嵌套结构</li>
</ol>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>使用<span class="code">`-`</span>, <span class="code">`=`</span>或者<span class="code">`*`</span>可以指定无序标签</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>直接使用数字可以形成有序标签, 值得注意的是, 数字显示的标签与输入的数字无关</span><br><span class="line"><span class="bullet">   1. </span>另外, 使用制表符也可以轻易的形成嵌套结构</span><br></pre></td></tr></table></figure>

<h2 id="4-段落"><a href="#4-段落" class="headerlink" title="4. 段落"></a>4. 段落</h2><p>markdown 没有特殊的段落格式要求, 主要因为 markdown 是基于文本构建, 所以不能让文本编辑过于复杂.<br>只需要在段落的最后添加两个空格或者留下一段空行即可换行.</p>
<h2 id="5-字体"><a href="#5-字体" class="headerlink" title="5. 字体"></a>5. 字体</h2><p>markdown 支持以下字体:</p>
<ul>
<li><em>斜体文本</em>.</li>
<li><em>斜体文本</em>.</li>
<li><strong>粗体文本</strong>.</li>
<li><strong>粗体文本</strong>.</li>
<li><strong><em>粗斜体文本</em></strong>.</li>
<li><strong><em>粗斜体文本</em></strong>.</li>
<li><del>删除文本</del>.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">_斜体文本_</span>.</span><br><span class="line"><span class="emphasis">_斜体文本_</span>.</span><br><span class="line"><span class="strong">**粗体文本**</span>.</span><br><span class="line"><span class="strong">**粗体文本**</span>.</span><br><span class="line"><span class="strong">**_粗斜体文本_*</span>*.</span><br><span class="line"><span class="strong">**_粗斜体文本_*</span>*.</span><br><span class="line">~~删除文本~~.</span><br></pre></td></tr></table></figure>

<h2 id="6-HTML-标签在-markdown-中的使用"><a href="#6-HTML-标签在-markdown-中的使用" class="headerlink" title="6. HTML 标签在 markdown 中的使用"></a>6. HTML 标签在 markdown 中的使用</h2><p>HTML 标签在 markdown 渲染时会自动转化.</p>
<ul>
<li>我们可以<mark>高亮文字</mark>.</li>
<li>可以<ins>添加文字下划线</ins>.</li>
<li>可以用另一种方法实现<del>删除线</del>.</li>
<li>或者可以<font color="red">修改字体颜色</font>.</li>
<li>为<ruby>生僻<rt>shēng pì</rt></ruby>字添加注音.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>我们可以<span class="xml"><span class="tag">&lt;<span class="name">mark</span>&gt;</span></span>高亮文字<span class="xml"><span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>可以<span class="xml"><span class="tag">&lt;<span class="name">ins</span>&gt;</span></span>添加文字下划线<span class="xml"><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>可以用另一种方法实现<span class="xml"><span class="tag">&lt;<span class="name">del</span>&gt;</span></span>删除线<span class="xml"><span class="tag">&lt;/<span class="name">del</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>或者可以<span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span></span>修改字体颜色等等<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span>.</span><br><span class="line"><span class="bullet">- </span>为<span class="xml"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span>生僻<span class="xml"><span class="tag">&lt;<span class="name">rt</span>&gt;</span></span>shēng pì<span class="xml"><span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span>字添加注音.</span><br></pre></td></tr></table></figure>

<h2 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7. 分割线"></a>7. 分割线</h2><p>实现原理很简单, 三个(或以上)连续的<code>-</code>或者<code>*</code>即可.</p>
<hr>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="7-注释"><a href="#7-注释" class="headerlink" title="7. 注释"></a>7. 注释</h2><p>markdown 对于文本注释的支持非常好[^非常好].<br>[^非常好]:所有的标注会自动编号并放在文章末尾</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">markdown 对于文本注释的支持非常好[^非常好].</span><br><span class="line">[<span class="symbol">^非常好</span>]:<span class="link">所有的标注会自动编号并放在文章末尾</span></span><br></pre></td></tr></table></figure>

<h2 id="8-代码区"><a href="#8-代码区" class="headerlink" title="8. 代码区"></a>8. 代码区</h2><p>使用 ` 符号可以形成行内代码词, 而三个 ` 则会形成代码块.<br>或者直接使用制表符(4 个空格)加在每行前面可以达到同样代码块的效果.</p>
<h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9. 表格"></a>9. 表格</h2><p>使用<code>|</code>符号来制作表格, 使用<code>:</code>来提示对齐方向.</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="center">班级</th>
<th align="right">成绩</th>
</tr>
</thead>
<tbody><tr>
<td align="left">xjywq</td>
<td align="center">1</td>
<td align="right">100</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 姓名  | 班级 | 成绩 |</span><br><span class="line">| :---- | :--: | ---: |</span><br><span class="line">| xjywq |  1   |  100 |</span><br></pre></td></tr></table></figure>

<h2 id="10-链接"><a href="#10-链接" class="headerlink" title="10. 链接"></a>10. 链接</h2><ul>
<li>可以使用<code>[]</code>符号管理显示的链接名称, <code>()</code>符号管理链接方向, <code>&quot;&quot;</code>符号管理链接标题, 如<a href="www.baidu.com" title="百度搜索">百度</a>.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">www.baidu.com "百度搜索"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>或者可以用<code>&lt;&gt;</code>显式指定链接, 如<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.baidu.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>或者可以使用注释类型, 将 7 和 10 结合, 如<a href="www.baidu.com" title="百度搜索">百度</a>, 但是注释之间必须留一个空行.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>][<span class="symbol">baidu</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">baidu</span>]: <span class="link">www.baidu.com "百度搜索"</span></span><br></pre></td></tr></table></figure>

<h2 id="11-图片"><a href="#11-图片" class="headerlink" title="11. 图片"></a>11. 图片</h2><ul>
<li>使用链接的格式, 但是在开头加上<code>!</code>, 链接地址使用本地路径(支持绝对路径与相对路径), 在 hexo 上无法正确显示, 需要文件的相对位置, 且位置起始地址为 sourse 文件夹下.</li>
</ul>
<p><img src="/picture/markdown-case/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg" alt="麻衣学姐"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">普通 markdown 文件中:</span><br><span class="line">![<span class="string">麻衣学姐</span>](<span class="link">/markdown-case/麻衣学姐.jpg</span>)</span><br><span class="line"></span><br><span class="line">在 hexo 中则是:</span><br><span class="line">![<span class="string">麻衣学姐</span>](<span class="link">/picture/markdown-case/麻衣学姐.jpg</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用在线图床, 同上</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xjywq/picgo/master/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg" alt="麻衣学姐" title="这是我的老婆"></p>
<ul>
<li>使用 HTML 语法</li>
</ul>
<img src="https://raw.githubusercontent.com/xjywq/picgo/master/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg" alt = "麻衣学姐">

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"hhttps://raw.githubusercontent.com/xjywq/picgo/master/%E9%BA%BB%E8%A1%A3%E5%AD%A6%E5%A7%90.jpg"</span> <span class="attr">alt</span> = <span class="string">"麻衣学姐"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="13-公式"><a href="#13-公式" class="headerlink" title="13. 公式"></a>13. 公式</h2><ul>
<li>markdown 可以通过简单的语法插入公式, 首先是通过<code>$</code>符号, 如$\frac{1+2}{2}=1.5$, 或者另一起一行作为独立公式$$\sum_{i=0}^n{\frac 1 n}=\infty$$</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内公式</span><br><span class="line">$\frac&#123;1+2&#125;&#123;2&#125;=1.5$</span><br><span class="line"></span><br><span class="line">单独公式</span><br><span class="line">$$\sum_&#123;i=0&#125;^n&#123;\frac 1 n&#125;=\infty$$</span><br></pre></td></tr></table></figure>

<ul>
<li><p>或者使用<a href="https://www.codecogs.com/eqnedit.php" target="_blank" rel="noopener">在线公式编辑器</a>, 可以复制得到的图像或者借助于下方的 HTML 方法</p>
</li>
<li><p>H 也可以直接手动使用 HTML 方法, 借助<a href="http://chart.googleapis.com/chart" target="_blank" rel="noopener">google chart</a>或者其他</p>
</li>
</ul>
<img src="http://chart.googleapis.com/chart?cht=tx&chl= \sum_{i=0}^n{\frac 1 n}=\infty" style="border:none;">

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">谷歌服务器</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://chart.googleapis.com/chart?cht=tx&amp;chl= \sum_&#123;i=0&#125;^n&#123;\frac 1 n&#125;=\infty"</span> <span class="attr">style</span>=<span class="string">"border:none;"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在这里贴一下一位大佬的<a href="https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan" target="_blank" rel="noopener">LaTeX 数学公式大全</a>, 很好用</p>
<h2 id="14-mermaid-使用"><a href="#14-mermaid-使用" class="headerlink" title="14. mermaid 使用"></a>14. mermaid 使用</h2><ul>
<li>部分 markdown 编辑器支持 mermaid 的流程图渲染等等, 可惜 hexo 并不支持这点(暂时没有装插件的打算, 可能以后会考虑)</li>
<li>可以看看 CSDN 上大佬发的 mermaid<a href="https://blog.csdn.net/weixin_33901641/article/details/90303528?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase" target="_blank" rel="noopener">实用教程</a></li>
</ul>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>文本编辑</tag>
      </tags>
  </entry>
  <entry>
    <title>catch_the_cat</title>
    <url>/2020/9/9/catch_the_cat/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在小猫周围建墙, 阻止它逃走吧, 不要让它跑到周围的地方哦<br><img src="/picture/catch_the_cat/catch_the_cat.jpg" alt="demo"></p>
<a id="more"></a>

<h2 id="地址链接"><a href="#地址链接" class="headerlink" title="地址链接"></a>地址链接</h2><p><a href="https://xjywq.github.io/catch_the_cat" target="_blank" rel="noopener" title="小游戏">小游戏地址</a></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在hexo的resource文件夹下建立catch_the_cat文件夹, 将js文件放在里面, 通过链接跳转即可</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">小游戏地址</span>](<span class="link">https://xjywq.github.io/catch_the_cat "小游戏"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>有机会我自己用js写一个五子棋试试, 在做了在做了.jpg</p>
]]></content>
      <tags>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>k近邻法</title>
    <url>/2020/9/9/k%E8%BF%91%E9%82%BB%E6%B3%95/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一种基本分类及回归方法. 我们仅仅考虑分类问题中的k近邻法. k近邻法的输入为实例的特征向量, 对应特征空间中的点; 输出为实例的类别, 可以有多种类别. 分类时, 根据其k个最近的训练实例的类别, 通过多数表决的方式进行预测. 因此, k近邻法不具有显式的学习过程, 实际是是对特征空间的划分, 以此为依据作为分类的”模型”.</p>
<p>k近邻法于1968年由Cover和Hart提出.</p>
<a id="more"></a>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>给定数据集<br>$$T=\ { (x_1,y_1),(x_2,y_2),…,(x_N,y_N)\ } $$<br>其中, $x_i$为实例的特征向量, $y_i$为实例的具体分类. $k$近邻旨在使用邻近的$k$个节点的分类得到实例所处的特征空间分类, 最终得到实例的分类, 具体的分类过程如下:</p>
<ul>
<li>根据给定的距离度量, 在训练集中找出与$x$最邻近的$k$个节点, 将涵盖这些点的$x$的邻域记为$N_k(x)$</li>
<li>在$N_k(x)$中根据分类决策法则决定$x$的类别$y$<br>$$y=argmax\sum_ {  { x_i } \in { N_k(x) }  }  { I(y_i=c_j) } , i=1,2,3…,N; j=1,2,…,K$$<br>其中$I$为指示函数, 即$y_i=c_j$时为1, 否则为0.</li>
</ul>
<p>$k$近邻法的特殊形式是$k=1$的情况, 称为最近邻算法. 对于输入的实例点(特征向量)$x$, 算法将训练集中最接近$x$的点的类作为$x$的类.</p>
<p>值得注意的是, $k$近邻法没有显式的学习过程, 即根据训练集直接得出训练模型.</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>$k$近邻法使用的模型实际上就是对特征空间的分类划分, 模型由三个基本要素——距离度量, $k$值的选择和分类决策决定.</p>
<h3 id="模型意义"><a href="#模型意义" class="headerlink" title="模型意义"></a>模型意义</h3><p>在$k$近邻法中, 但训练集, 距离度量, k值以及分类决策被确定后, 模型空间将被唯一确定, 相当于为空间确定一种划分, 可以理解为涂色, 所以这些色块中每个点的分类都很清楚.</p>
<p><img src="https://github.com/xjywq/picgo/blob/master/k%E8%BF%91%E9%82%BB%E6%B3%95/%E6%A8%A1%E5%9E%8B1.jpg?raw=true" alt="模型1"></p>
<p>在特征空间中, 对每个训练实例点$x_i$, 距离该点比其他点更近的所有点组成一个区域, 叫做单元(cell). 每个训练实例点的类别是确定的, 以上是二位特征空间划分的一个例子.</p>
<h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>特征空间中两个实例点间的距离是两个实例点相似程度的反应. $k$近邻模型的特征空间一般是n维实数向量空间$R^n$. 使用的距离是欧式距离, 但也可以是更加普遍的距离如$L_p$距离($L_p$ distance)或者叫Minkowski距离(Minkowski distance).</p>
<p>令$x_i, x_j \in R^n$, 则$x_i, x_j$的$L_p$距离定义为<br>$$L_p(x_i, x_j)=(\sum_ { l=1 } ^ { n }  { |x_i^ { (l) } -x_j^ { (l) } |^p } )^ { \frac1p } $$<br>这里$p\geq1$. 当$p=2$时, 称为欧式距离(Euclidean distance), 即<br>$$L_2(x_i, x_j)=(\sum_ { l=1 } ^ { n }  { |x_i^ { (l) } -x_j^ { (l) } |^2 } )^ { \frac12 } $$<br>当$p=1$时, 称为曼哈顿距离(Manhattan distance), 即<br>$$L_2(x_i, x_j)=\sum_ { l=1 } ^ { n }  { |x_i^ { (l) } -x_j^ { (l) } | } $$<br>当$p=\infty$时, 它是各个坐标差的最大值, 即<br>$$L_\infty(x_i, x_j)=\max_ { l }  { |x_i^ { (l) } -x_j^ { (l) } | } $$<br>下图是p取不同值时, 与原点的$L_p$距离为1的点的图形.</p>
<p><img src="https://github.com/xjywq/picgo/blob/master/k%E8%BF%91%E9%82%BB%E6%B3%95/Lp1.jpg?raw=true" alt="Lp distence"></p>
<h3 id="k值的选择"><a href="#k值的选择" class="headerlink" title="k值的选择"></a>k值的选择</h3><p>$k$值的选择会对$k$近邻法的结果产生重大影响.<br>如果$k$值比较小, 相当于每个训练实例的作用空间减小了, 那么模型学习的”近似误差”(approximation error)会减小, 只有与输入实例较为接近的训练实例才会对预测起作用. 然而学习的”估计误差”就会减小, 也就更容易受到噪声的影响.</p>
<p>换句话说, $k$值的减小会使模型的复杂度整体上升, 更容易发生过拟合.</p>
<p>当然, $k$值的增大就意味着模型的复杂度下降, 也更容易忽略小片的区域. 如果$k=N$, 模型就简化为相同的空间, 无论输入是什么, 都将得到同样的分类结果, 这是不可取的.</p>
<p>在应用中, $k$一般取一个较小的数值. 通常采用交叉验证的方法来选取最优的$k$值.</p>
<h3 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h3><p>$k$近邻法中的分类决策规则往往采用多数表决, 即由输入实例的$k$个近邻训练实例中的多数表现决定输入实例的类.</p>
<p>多数表决规则(majority voting rule)有如下解释: 如果分类的损失函数为0-1损失函数, 分类函数为<br>$$f:R^n \to \ { c_1,c_2,…,c_K\ } $$<br>那么误分类概率为<br>$$P(Y\not=f(X))=1-P(Y=f(X))$$<br>对给定的$x$, 其最邻近的$k$个训练实例构成集合$N_k(x)$. 如果涵盖$N_k(x)$的区域类别为$c_j$, 那么误分类率是<br>$$\frac1k\sum_ { x_i\in N_k(x) }  { I(y_i\not=c_j) } =1-\frac1k\sum_ { x_i\in N_k(x) }  { I(y_i=c_j) } $$<br>要使误分类率最小, 就要使$\sum_ { x_i\in N_k(x) }  { I(y_i=c_j) } $最大, 所以多数表决规则等价于经验风险最小化.</p>
<h2 id="k邻近法的实现"><a href="#k邻近法的实现" class="headerlink" title="k邻近法的实现"></a>k邻近法的实现</h2><p>$k$邻近法的实现方法有很多, 主要考虑的问题是如何对训练数据进行快速$k$近邻搜索. 这点在特征空间的维数较大及训练数据容量较大时尤其必要.</p>
<p>当然最简单的方法是线性扫描, 但是这种方法并不持久可行.</p>
<p>具体的实现方法此处不多加赘述, 一般使用kd树, 是一种高维空间的树形数据结构, 表示对$k$维超平面的一种划分.</p>
<p>我在另一篇博客中会具体的介绍kd树的建立原理以及实现, <a href="https://xjywq.github.io/2020/9/21/KD-Tree/" target="_blank" rel="noopener">点击此处可以跳转</a>.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>$k$近邻算法是基本且简单的分类回归算法, $k$近邻法的基本做法是: 对给定的训练实例点和输入实例点, 首先确定输入实例点最近的$k$个训练实例点, 然后利用这$k$个训练实例点的分类预测输入实例点的分类.</li>
<li>$k$近邻模型对应特征空间的一种划分, 当训练集, 距离度量, $k$值以及分类决策规则确定后, 其结果唯一确定.</li>
<li>$k$近邻法三要素: 距离度量, $k$值的选取以及分类决策的规则.</li>
<li>$k$近邻法的实现需要考虑如何快速搜索邻近的$k$个点. kd树是高维空间下的二叉树数据结构, 能省去大部分搜索, 从而提升访问速度.</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>KD-Tree</title>
    <url>/2020/9/21/KD-Tree/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>KD 树是一种对 k 维空间中实例点的划分进行储存以便对其进行快速检索的树形数据结构, KD 树为二叉树, 每个分支表示对 k 维空间的一个划分(partition). 构造 KD 树相当于不断用垂直于坐标轴的超平面将 k 维空间划分, 构成一系列的 k 维超矩形区域, KD 树的每一个叶子节点对应一个 k 维的超矩形区域.</p>
<p>本文针对 python, 介绍了 python 构建和使用 KD 树的方法和实现.</p>
<a id="more"></a>

<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><ul>
<li>构造根节点, 使根节点对应于 k 维空间中包含所有实例点的超矩形区域, 通过下面的递归方法, 不断对 k 维空间进行切分.</li>
<li>在超矩形上选一个坐标轴和在此坐标轴上的一个切分点, 确定一个超平面, 这个超平面通过选定的切分点并垂直于选定的坐标轴. 这时, 实例被分到两个子区域.</li>
<li>这个过程一直持续到子区域内没有实例时终止, 在过程中, 将实例保存在相应的节点上.</li>
<li>通常, 选择的训练实例点在选定坐标轴上的中位数为切分点, 这样会得到平衡的 KD 树, 但值得注意的是, 平衡的 KD 树搜索效率未必是最优的.</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>为了方便起见, 我们使用 python 处理数据, 当然 python 中也有很多模块可以直接使用, 比如<code>kd</code>, <code>scipy</code>等等. 当然此处我们选择使用源码实现.</p>
<ul>
<li>首先是对树进行构建, 为此我们需要定义树的节点, 如下:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KD_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elt=None, split=None, LL=None, RR=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        @param: elt Data: 数据点</span></span><br><span class="line"><span class="string">        @param: split number: 划分维度</span></span><br><span class="line"><span class="string">        @param: LL, RR KD_node: 节点的左儿子跟右儿子</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.elt = elt</span><br><span class="line">        self.split = split</span><br><span class="line">        self.left = LL</span><br><span class="line">        self.right = RR</span><br></pre></td></tr></table></figure>

<ul>
<li>然后是对树的生成, 我们选择计算每个维度的方差, 选择其中最大值, 这样虽然在建立 KD 树时会增加生成时间, 但是在搜索时可以节省时间^[另有方法是取一个 Hash 函数, 这样虽然建立时节省了大量时间, 却不能对搜索进行优化, 两种方法各有优势, 可自行选择], 使用递归计算分类的维度后对没个点分类切片^[值得注意的是为了节省空间, 经过构建后 Datalist 会被以一定规则排序], 使用的距离规则为欧拉距离, 即取平方加和再开根号.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createKDTree</span><span class="params">(root, data_list)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: root KD_node: 当前树的根节点</span></span><br><span class="line"><span class="string">    @param: data_list list: 数据点的集合(无序)</span></span><br><span class="line"><span class="string">    @return: root KD_node: 构造的KDTree的树根</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    LEN = len(data_list)</span><br><span class="line">    <span class="keyword">if</span> LEN == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 数据点的维度</span></span><br><span class="line">    dimension = len(data_list[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 方差</span></span><br><span class="line">    max_var = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 最后选择的划分域</span></span><br><span class="line">    split = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(dimension):</span><br><span class="line">        ll = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> data_list:</span><br><span class="line">            ll.append(t[i])</span><br><span class="line">        var = computeVariance(ll)</span><br><span class="line">        <span class="keyword">if</span> var &gt; max_var:</span><br><span class="line">            max_var = var</span><br><span class="line">            split = i</span><br><span class="line">    <span class="comment"># 根据划分域的数据对数据点进行排序</span></span><br><span class="line">    data_list.sort(key=<span class="keyword">lambda</span> x: x[split])</span><br><span class="line">    <span class="comment"># 选择下标为len // 2的点作为分割点</span></span><br><span class="line">    elt = data_list[LEN // <span class="number">2</span>]</span><br><span class="line">    root = KD_node(elt, split)</span><br><span class="line">    root.left = createKDTree(root.left, data_list[<span class="number">0</span>:(LEN // <span class="number">2</span>)])</span><br><span class="line">    root.right = createKDTree(root.right, data_list[(LEN // <span class="number">2</span> + <span class="number">1</span>):LEN])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeVariance</span><span class="params">(arrayList)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: arrayList list: 存放的数据点</span></span><br><span class="line"><span class="string">    @return: variance number: 返回数据点的方差</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> ele <span class="keyword">in</span> arrayList:</span><br><span class="line">        ele = float(ele)</span><br><span class="line">    LEN = float(len(arrayList))</span><br><span class="line">    array = np.array(arrayList)</span><br><span class="line">    sum1 = array.sum()</span><br><span class="line">    array2 = array * array</span><br><span class="line">    sum2 = array2.sum()</span><br><span class="line">    mean = sum1 / LEN</span><br><span class="line">    <span class="comment"># D[X] = E[x^2] - (E[x])^2 使用欧拉距离</span></span><br><span class="line">    variance = sum2 / LEN - mean**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> variance</span><br></pre></td></tr></table></figure>

<ul>
<li>之后便是搜索的定义和使用, 我们定义具体的距离计算公式, 并通过栈寻找最邻近的点, 返回点与其距离.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findNN</span><span class="params">(root, query)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: root KD_node: KDTree的树根</span></span><br><span class="line"><span class="string">    @param: query Data: 查询点</span></span><br><span class="line"><span class="string">    @return: NN,mindist KD_node,number: 返回距离data最近的点NN，同时返回最短距离min_dist</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 初始化为root的节点</span></span><br><span class="line">    NN = root.elt</span><br><span class="line">    min_dist = computeDist(query, NN)</span><br><span class="line">    nodeList = []</span><br><span class="line">    temp_root = root</span><br><span class="line">    <span class="comment"># 二分查找建立路径</span></span><br><span class="line">    <span class="keyword">while</span> temp_root:</span><br><span class="line">        nodeList.append(temp_root)</span><br><span class="line">        dd = computeDist(query, temp_root.elt)</span><br><span class="line">        <span class="keyword">if</span> min_dist &gt; dd:</span><br><span class="line">            NN = temp_root.elt</span><br><span class="line">            min_dist = dd</span><br><span class="line">        <span class="comment"># 当前节点的划分域</span></span><br><span class="line">        ss = temp_root.split</span><br><span class="line">        <span class="keyword">if</span> query[ss] &lt;= temp_root.elt[ss]:</span><br><span class="line">            temp_root = temp_root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp_root = temp_root.right</span><br><span class="line">    <span class="comment"># 回溯查找</span></span><br><span class="line">    <span class="keyword">while</span> nodeList:</span><br><span class="line">        <span class="comment"># 使用list模拟栈，后进先出</span></span><br><span class="line">        back_elt = nodeList.pop()</span><br><span class="line">        ss = back_elt.split</span><br><span class="line">        <span class="comment"># 判断是否需要进入父亲节点的子空间进行搜索</span></span><br><span class="line">        <span class="keyword">if</span> abs(query[ss] - back_elt.elt[ss]) &lt; min_dist:</span><br><span class="line">            <span class="keyword">if</span> query[ss] &lt;= back_elt.elt[ss]:</span><br><span class="line">                temp_root = back_elt.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp_root = back_elt.left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> temp_root:</span><br><span class="line">                nodeList.append(temp_root)</span><br><span class="line">                curDist = computeDist(query, temp_root.elt)</span><br><span class="line">                <span class="keyword">if</span> min_dist &gt; curDist:</span><br><span class="line">                    min_dist = curDist</span><br><span class="line">                    NN = temp_root.elt</span><br><span class="line">    <span class="keyword">return</span> NN, min_dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeDist</span><span class="params">(pt1, pt2)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @function: 计算两个数据点的距离</span></span><br><span class="line"><span class="string">    @param: pt1, pt2 point: 输入的数据点</span></span><br><span class="line"><span class="string">    @return: sum number: pt1和pt2之间的距离</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    sum = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pt1)):</span><br><span class="line">        sum = sum + (pt1[i] - pt2[i]) * (pt1[i] - pt2[i])</span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum)</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>至此, KD 树就搭建完毕了, 下面是一份简单的测试源码和完整代码, 不过目前这个 KD 树只支持寻找最近的节点, 如果有兴趣可以自行修改 findNN 函数, 使其返回包含最近的 k 个节点的列表.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">@Description: KD-Tree:</span></span><br><span class="line"><span class="string">@Date     :2020/09/22 00:24:36</span></span><br><span class="line"><span class="string">@Author      :xjywq</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KD_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elt=None, split=None, LL=None, RR=None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        @param: elt Data: 数据点</span></span><br><span class="line"><span class="string">        @param: split number: 划分维度</span></span><br><span class="line"><span class="string">        @param: LL, RR KD_node: 节点的左儿子跟右儿子</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.elt = elt</span><br><span class="line">        self.split = split</span><br><span class="line">        self.left = LL</span><br><span class="line">        self.right = RR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createKDTree</span><span class="params">(root, data_list)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: root KD_node: 当前树的根节点</span></span><br><span class="line"><span class="string">    @param: data_list list: 数据点的集合(无序)</span></span><br><span class="line"><span class="string">    @return: root KD_node: 构造的KDTree的树根</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    LEN = len(data_list)</span><br><span class="line">    <span class="keyword">if</span> LEN == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 数据点的维度</span></span><br><span class="line">    dimension = len(data_list[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 方差</span></span><br><span class="line">    max_var = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 最后选择的划分域</span></span><br><span class="line">    split = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(dimension):</span><br><span class="line">        ll = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> data_list:</span><br><span class="line">            ll.append(t[i])</span><br><span class="line">        var = computeVariance(ll)</span><br><span class="line">        <span class="keyword">if</span> var &gt; max_var:</span><br><span class="line">            max_var = var</span><br><span class="line">            split = i</span><br><span class="line">    <span class="comment"># 根据划分域的数据对数据点进行排序</span></span><br><span class="line">    data_list.sort(key=<span class="keyword">lambda</span> x: x[split])</span><br><span class="line">    <span class="comment"># 选择下标为len / 2的点作为分割点</span></span><br><span class="line">    elt = data_list[LEN // <span class="number">2</span>]</span><br><span class="line">    root = KD_node(elt, split)</span><br><span class="line">    root.left = createKDTree(root.left, data_list[<span class="number">0</span>:(LEN // <span class="number">2</span>)])</span><br><span class="line">    root.right = createKDTree(root.right, data_list[(LEN // <span class="number">2</span> + <span class="number">1</span>):LEN])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeVariance</span><span class="params">(arrayList)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: arrayList list: 存放的数据点</span></span><br><span class="line"><span class="string">    @return: variance number: 返回数据点的方差</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> ele <span class="keyword">in</span> arrayList:</span><br><span class="line">        ele = float(ele)</span><br><span class="line">    LEN = float(len(arrayList))</span><br><span class="line">    array = np.array(arrayList)</span><br><span class="line">    sum1 = array.sum()</span><br><span class="line">    array2 = array * array</span><br><span class="line">    sum2 = array2.sum()</span><br><span class="line">    mean = sum1 / LEN</span><br><span class="line">    <span class="comment">#D[X] = E[x^2] - (E[x])^2</span></span><br><span class="line">    variance = sum2 / LEN - mean**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> variance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findNN</span><span class="params">(root, query)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @param: root KD_node: KDTree的树根</span></span><br><span class="line"><span class="string">    @param: query Data: 查询点</span></span><br><span class="line"><span class="string">    @return: NN,mindist KD_node,number: 返回距离data最近的点NN，同时返回最短距离min_dist</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 初始化为root的节点</span></span><br><span class="line">    NN = root.elt</span><br><span class="line">    min_dist = computeDist(query, NN)</span><br><span class="line">    nodeList = []</span><br><span class="line">    temp_root = root</span><br><span class="line">    <span class="comment"># 二分查找建立路径</span></span><br><span class="line">    <span class="keyword">while</span> temp_root:</span><br><span class="line">        nodeList.append(temp_root)</span><br><span class="line">        dd = computeDist(query, temp_root.elt)</span><br><span class="line">        <span class="keyword">if</span> min_dist &gt; dd:</span><br><span class="line">            NN = temp_root.elt</span><br><span class="line">            min_dist = dd</span><br><span class="line">        <span class="comment"># 当前节点的划分域</span></span><br><span class="line">        ss = temp_root.split</span><br><span class="line">        <span class="keyword">if</span> query[ss] &lt;= temp_root.elt[ss]:</span><br><span class="line">            temp_root = temp_root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp_root = temp_root.right</span><br><span class="line">    <span class="comment"># 回溯查找</span></span><br><span class="line">    <span class="keyword">while</span> nodeList:</span><br><span class="line">        <span class="comment"># 使用list模拟栈，后进先出</span></span><br><span class="line">        back_elt = nodeList.pop()</span><br><span class="line">        ss = back_elt.split</span><br><span class="line">        <span class="comment"># 判断是否需要进入父亲节点的子空间进行搜索</span></span><br><span class="line">        <span class="keyword">if</span> abs(query[ss] - back_elt.elt[ss]) &lt; min_dist:</span><br><span class="line">            <span class="keyword">if</span> query[ss] &lt;= back_elt.elt[ss]:</span><br><span class="line">                temp_root = back_elt.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp_root = back_elt.left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> temp_root:</span><br><span class="line">                nodeList.append(temp_root)</span><br><span class="line">                curDist = computeDist(query, temp_root.elt)</span><br><span class="line">                <span class="keyword">if</span> min_dist &gt; curDist:</span><br><span class="line">                    min_dist = curDist</span><br><span class="line">                    NN = temp_root.elt</span><br><span class="line">    <span class="keyword">return</span> NN, min_dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeDist</span><span class="params">(pt1, pt2)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    @function: 计算两个数据点的距离</span></span><br><span class="line"><span class="string">    @param: pt1, pt2 point: 输入的数据点</span></span><br><span class="line"><span class="string">    @return: sum number: pt1和pt2之间的距离</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    sum = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pt1)):</span><br><span class="line">        sum = sum + (pt1[i] - pt2[i]) * (pt1[i] - pt2[i])</span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = KD_node()</span><br><span class="line">    Data = [[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]] <span class="comment"># 简单的测试代码</span></span><br><span class="line">    Tree = createKDTree(root, Data) <span class="comment"># 建立树</span></span><br><span class="line"></span><br><span class="line">    NN, min_dist = findNN(Tree, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">    print(NN, min_dist)</span><br><span class="line">    NN, min_dist = findNN(Tree, [<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2</span>])</span><br><span class="line">    print(NN, min_dist)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>深度学习</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论与随机过程</title>
    <url>/2020/12/25/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>本文创作于期末考试前3天, 根据目录整理概率论与随机过程课程学习的要点, 同时方便以后进行复习和重复使用.<br>课程用书: 《概率论与随机过程》(北京邮电大学出版社)</p>
<a id="more"></a>

<h2 id="第一章-随机事件和概率"><a href="#第一章-随机事件和概率" class="headerlink" title="第一章 随机事件和概率"></a>第一章 随机事件和概率</h2><h3 id="随机事件及其运算"><a href="#随机事件及其运算" class="headerlink" title="随机事件及其运算"></a>随机事件及其运算</h3><ol>
<li><p>随机事件、样本空间、样本点的定义</p>
</li>
<li><p>对于事件的关系与运算有</p>
<ul>
<li>$\bar{A}=\Omega-A,\bar{\Omega}=\emptyset,\bar{\emptyset}=\Omega$</li>
<li>若$A\subset B$, 则$\bar{B}\subset\bar{A}$</li>
<li>$A-B=A\bar{B}=A-AB,A=AB\cup A\bar{B},A(B\cup\bar{B})=A$</li>
<li>$A\cup B=A\cup\bar{A}B=B\cup A\bar{B},A\cup B\cup C=A\cup\bar{A}B\cup\bar{A}\bar{B}C$</li>
<li>若 $A、B$ 互为对立事件, 则 $A、B$ 互不相容</li>
</ul>
</li>
<li><p>事件的运算符合四种运算法则: 交换律、结合律、分配律、对欧律</p>
</li>
</ol>
<h3 id="古典概型、几何概型"><a href="#古典概型、几何概型" class="headerlink" title="古典概型、几何概型"></a>古典概型、几何概型</h3><ol>
<li><p>古典概型</p>
<ul>
<li><p>以有限可能发生有限种基本事件</p>
</li>
<li><p>古典概型的概率: $P(A)=\dfrac{r}{n}$</p>
</li>
<li><p>古典概型具有下列性质:</p>
<ul>
<li>非负性: 对于每个事件 $A$, 有 $0\leqslant P(A)\leqslant1$</li>
<li>规范性: $P(\Omega)=1$</li>
<li>有限可加性: $$P\left(\bigcup_{i=1}^mA_i\right)=\sum_{i=1}^mP(A_i)$$</li>
</ul>
</li>
<li><p>对于古典概率问题, 关键在于正确计算样本空间大小和事件所包含的样本点个数</p>
</li>
</ul>
</li>
<li><p>几何概率</p>
<ul>
<li>几何概率中每个样本点出现的概率依旧是等可能的, 但是将样本点的个数拓展到无穷, 将试验几何抽象后计算有限的几何度量. 满足如下条件的被称为几何概率:<ol>
<li>样本空间是直线或者二维、三维空间中的有限的区间或区域</li>
<li>样本点在其上是均匀分布的</li>
</ol>
</li>
<li>在几何概型中若样本空间 $\Omega$ 对应的区域的度量为 $L(\Omega)$, 且事件 $A$ 的度量为 $L(A)$, 则事件 $A$ 的概率为 $P(A)=\dfrac{L(A)}{L(\Omega)}$</li>
<li>几何概型具有以下性质<ul>
<li>非负性: 对于每个事件 $A$, 有 $0\leqslant P(A)\leqslant1$</li>
<li>规范性: $P(\Omega)=1$</li>
<li>可列可加性: 若 $A_1,A_2,\dots$ 是两两互不相容的事件, 则有: $$P\left(\bigcup_{i=1}^mA_i\right)=\sum_{i=1}^mP(A_i)$$</li>
</ul>
</li>
<li>*贝特朗(Bertrand)悖论<br>在单位圆上随机做一条弦, 求其长度超过该圆内接等边三角形边长的概率. 根据不同的理论可以得到多种不同的解答, 且都是正确的.<br><a href="https://baike.baidu.com/item/%E8%B4%9D%E7%89%B9%E6%9C%97%E6%82%96%E8%AE%BA" target="_blank" rel="noopener">百度链接</a></li>
</ul>
</li>
</ol>
<h3 id="条件概率、乘法公式、全概率公式、Bayes公式"><a href="#条件概率、乘法公式、全概率公式、Bayes公式" class="headerlink" title="条件概率、乘法公式、全概率公式、Bayes公式"></a>条件概率、乘法公式、全概率公式、Bayes公式</h3><ol>
<li>条件概率与乘法公式<ul>
<li>在实际问题中, 除了要考虑事件 $A$ 和其概率 $P(A)$ 还要考虑其在某些附加条件(已知条件)下的概率. 通常以 “事件 $B$” 已发生的形式给出, 此时事件 $A$ 的概率称为条件概率, 记为 $P(A|B)$</li>
<li>定义: $P(A|B)=\dfrac{P(AB)}{P(B)}$</li>
<li>条件概率有如下性质:<ul>
<li>$0\leqslant P(A|B)\leqslant1$</li>
<li>$P(\Omega|B)=1$</li>
<li>若 $A_1,A_2,\dots,$ 是两两互不相容事件, 则有:$$P(\cup_{i=1}^\infty A_i|B)=\sum_{i=1}^\infty P(A_i|B)$$</li>
</ul>
</li>
<li>乘法公式: $P(AB)=P(A|B)P(B)=P(B|A)P(A)$<br>推广后有: $P(ABC)=P(C|AB)P(B|A)P(B)$</li>
</ul>
</li>
<li>全概率公式<br>$$P(A)=\sum_{i=1}^\infty P(A|B_i)P(B_i)$$</li>
<li>Bayes公式<br>$$P(B_i|A)=\dfrac{P(B_iA)}{P(A)}=\dfrac{P(A|B_i)P(B_i)}{\sum_{k=1}^{n}P(A|B_k)P(B_k)}$$</li>
</ol>
<h3 id="事件的独立性"><a href="#事件的独立性" class="headerlink" title="事件的独立性"></a>事件的独立性</h3><p>两个事件相互独立表明一件事件的发生与否不影响另一个事件的发生, $A、B$ 事件独立的充要条件为 $P(AB)=P(A)P(B)$<br>当两个事件互相独立时有性质: $P(A)=P(A|B)、P(B)=P(B|A)$<br>对于多个事件的独立性有: $P(A_1A_2…A_n)=P(A_1)P(A_2)…P(A_n)$</p>
<h3 id="伯努利模型"><a href="#伯努利模型" class="headerlink" title="伯努利模型"></a>伯努利模型</h3><p>若实验 $E$ 只有 $A$ 和 $\bar{A}$ 两种结果且 $P(A)=p$, 则称 $E$ 为伯努利实验, 若将 $E$ 独立重复 $n$ 次, 则称这种实验为 $n$ 重伯努利实验.<br>令 $P(A)=p$, 则在 $n$ 重实验中事件 $A$ 恰好出现 $k$ 次的概率为 $P_n(k)=C_n^kp^k(1-p)^{n-k}$</p>
<h2 id="第二章-随机变量及其分布"><a href="#第二章-随机变量及其分布" class="headerlink" title="第二章 随机变量及其分布"></a>第二章 随机变量及其分布</h2><h3 id="随机变量的定义和分布函数"><a href="#随机变量的定义和分布函数" class="headerlink" title="随机变量的定义和分布函数"></a>随机变量的定义和分布函数</h3><p>设 $X$ 为随机变量, 则称函数$$F(x)=P(X\leqslant x)=P{\omega|X(\omega)\leqslant x}$$为随机变量 $X$ 的分布函数, 可以简写为 $d.f.$<br>分布函数具有一家基本性质:</p>
<ol>
<li>不减性: 若 $x_1&lt;x_2$, 则 $F(x_1)&lt;F(x_2)$</li>
<li>规范性: $0\leqslant F(x)\leqslant1$, 且 $\lim_{x\rightarrow-\infty}=0,~\lim_{x\rightarrow\infty}=1$</li>
<li>右连续性: 对于任意实数 $x$, $F(x+0)=F(x)$</li>
</ol>
<h3 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h3><p>离散型随机变量 $X$ 的分布律一般使用表格或图形的形式:</p>
<table>
<thead>
<tr>
<th>X</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$…$</th>
<th>$x_n$</th>
<th>$…$</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>$p_1$</td>
<td>$p_2$</td>
<td>$…$</td>
<td>$p_n$</td>
<td>$…$</td>
</tr>
</tbody></table>
<p>分布律具有如下性质:</p>
<ol>
<li><p>非负性: $p_k\geqslant0,k=1,2,…$</p>
</li>
<li><p>规范性: $\sum_{k=1}^\infty p_k=1$<br>几种常见的离散型随机变量</p>
</li>
<li><p>二项分布与 $n$重伯努利实验<br>若离散型变量 $X$ 的分布律为 $P_n(k)=C_n^kp^k(1-p)^{n-k}$, 则称 $X$ 服从参数为 $n,p$ 的二项分布, 记为 $X\sim b(n,p)$<br>泊松定理为二项分布提供了简易计算的方法, 当 $n$ 很大而 $p$ 很小的时候有$$C_n^kp^k(1-p)^{n-k}\approx\dfrac{\lambda^ke^{-\lambda}}{k!}$$<br>其中 $\lambda=np$</p>
</li>
<li><p>泊松分布与泊松流<br>设离散性随机变量 $X$ 的分布律为$$P{X=k}=\dfrac{\lambda^ke^{-\lambda}}{k!},k=1,2,…$$<br>其中 $\lambda&gt;0$ 是常数, 则称 $X$ 是服从参数为 $\lambda$ 的泊松分布, 记为 $X\sim\pi(\lambda)$</p>
</li>
</ol>
<h3 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h3><p>设变量 $X$ 的分布函数为 $F(x)$, 若存在非负函数 $f(x)$ 使得对于任意实数 $x$ 有:$$F(x)=\int_{-\infty}^{x}f(t)dt$$则称 $X$ 为连续型随机变量, 其中函数 $f(x)$ 称为随机变量 $X$ 的概率密度函数, 简称为概率密度, 可简写为 $p.d.$<br>对于连续型随机变量的分布函数有如下性质:</p>
<ol>
<li>$F(x)$ 为连续函数</li>
<li>对于连续型随机变量 $X$, 它取指定实数 $a$ 的概率均为 $0$, 即 $P{X=a}=0$</li>
</ol>
<p>三种重要的连续型随机变量</p>
<ol>
<li>均匀分布<br>$$f(x)=\begin{cases}\dfrac{1}{b-a},&amp;a&lt;x&lt;b\0,&amp;其他\end{cases}$$<br>称 $X$ 在区间 $(a,b)$ 上服从均匀分布, 记为 $X\sim U(a,b)$</li>
<li>指数分布<br>设连续型随机变量 $X$ 的概率密度为$$f(x)=\begin{cases}\lambda e^{-\lambda x},&amp;x&gt;0\0,&amp;x\leqslant0\end{cases}$$其中 $\lambda&gt;0$ 为常数, 则称 $X$ 服从参数为 $\lambda$ 的指数分布, 记为 $X\sim Ex(\lambda)$<br>指数分布的分布函数为$$F(x)=\begin{cases}1-e^{-\lambda x},&amp;x&gt;0\0,&amp;x\leqslant0\end{cases}$$<br>指数函数有一个很重要的特性是无记忆性, 即对于任意 $s&gt;0,t&gt;0$, 有$$P{X\geqslant s+t|X\geqslant s}=P{X\geqslant t}$$</li>
<li>正态分布<br>设随机变量 $X$ 的概率密度为$$f(x)=\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\dfrac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;+\infty$$其中 $\mu,\sigma(\sigma&gt;0)$ 是常数, 则称 $X$ 服从参数为 $\mu,\sigma^2$ 的正态分布, 记为 $X\sim N(\mu,\sigma^2)$<br>若 $\mu=0,\sigma=1$, 则称为标准正态分布, 记为 $\Phi(x)=\dfrac{1}{\sqrt{2\pi}}\int_{-\infty}^{x}e^{-\dfrac{t^2}{2}}dt$, 通常使用查表的方式求值<br>容易证明 $\Phi(x)$ 有如下常用性质:<ol>
<li>对于任意实数 $x$, 有 $\Phi(x)+\Phi(-x)=1$</li>
<li>$\Phi(0)=0.5$</li>
<li>若 $X\sim N(\mu, \sigma^2)$, 分布函数为 $F(x)$, 则 $F(x)=\Phi(\dfrac{x-\mu}{\sigma})$</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模大赛笔记</title>
    <url>/2021/1/14/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%A4%A7%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>数学建模大赛的笔记, 供自己学习和比赛使用, 老是喜欢开一些自己不会填上的坑. 希望建模大赛可以善始善终orz.</p>
<a id="more"></a>

<h2 id="比赛简介"><a href="#比赛简介" class="headerlink" title="比赛简介"></a>比赛简介</h2><h3 id="比赛形式"><a href="#比赛形式" class="headerlink" title="比赛形式"></a>比赛形式</h3><ul>
<li>正式比赛时间为 <code>北京时间2月5号凌晨6点</code> 发放题目, 至 <code>2月9号早上10点</code> 截至. 建议至少提前一个小时发邮件给 <a href="mailto:solutions@comap.com">solutions@comap.com</a>.</li>
<li>赛题共分 <code>A</code> 到 <code>E</code> 五个赛题, 其中本科生可在 <code>A</code>, <code>B</code>, <code>C</code> 三题中选择. 其中 <code>A</code>, <code>B</code> 题需要使用一定物理技巧解决, <code>C</code> 题则更需要计算机模拟, 建模的技术.</li>
</ul>
<h3 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h3><p>比赛由一个三人小组参加, 按照分工为 <code>建模手</code>, <code>程序手</code>, <code>写作手</code>, 其中三个部分之间有非常多的交叉, 所以需要各位组员积极商量, 尤其是建模的部分, 这是整个比赛的核心.</p>
<h2 id="常用模型和算法"><a href="#常用模型和算法" class="headerlink" title="常用模型和算法"></a>常用模型和算法</h2><h3 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h3><h4 id="1-路径"><a href="#1-路径" class="headerlink" title="1. 路径"></a>1. 路径</h4><ol>
<li>最短路算法<ol>
<li>广度优先算法<ul>
<li>单源最短路径(从源点 $s$ 到其它所有顶点 $v$).</li>
<li>有向图和无向图(无向图可以看作($u$, $v$), ($v$, $u$)同属于边集 $E$ 的有向图).</li>
<li>无权值.</li>
</ul>
</li>
<li>Bellman-Ford<ul>
<li>单源最短路径(从源点 $s$ 到其它所有顶点$v$).</li>
<li>有向图和无向图(无向图可以看作($u$, $v$), ($v$, $u$)同属于边集 $E$ 的有向图).</li>
<li>边权可正可负(如有负权回路输出错误提示).</li>
<li>差分约束系统.</li>
</ul>
</li>
<li>Dijkstra<ul>
<li>基于贪心算法和广度优先算法.</li>
<li>有向图和无向图(无向图可以看作($u$, $v$), ($v$, $u$)同属于边集 $E$ 的有向图).</li>
<li>可能不能处理负权环的情况.</li>
</ul>
</li>
<li>Floyd<ul>
<li>改进后的Dijkstra算法.</li>
<li>基于贪心算法.</li>
<li>有向图和无向图(无向图可以看作($u$, $v$), ($v$, $u$)同属于边集 $E$ 的有向图).</li>
<li>可能不能处理负权环的情况.</li>
</ul>
</li>
</ol>
</li>
<li>哈密顿路的TSP问题<ol>
<li>近似解</li>
<li>精确解</li>
</ol>
</li>
</ol>
<h4 id="2-树"><a href="#2-树" class="headerlink" title="2. 树"></a>2. 树</h4><ol>
<li>最小生成树<br>非常棒的B站视频, <a href="https://www.bilibili.com/video/BV1Eb41177d1?from=search&seid=9978770545718154739" target="_blank" rel="noopener">点击此处</a>跳转.<ol start="2">
<li>Kruskal算法<br>将所有边变成一个集合, 每次选取最小边, 判断是否形成环, 直到选取了 $n-1$ 条边则已经选出了最小生成树.</li>
<li>Prim算法<br>循环维护 $3$ 个列表, 选定点集合, 最小边集合和母边集合. 每次从已选定点和未选定点中选择最短 “桥梁”, 知道所有点都在同一个集合之中.</li>
</ol>
</li>
<li>哈夫曼树<br>本质上为一种编码树, 是构成某些内容的最小生成编码树.</li>
<li>斯坦纳树<br>斯坦纳树问题是组合优化问题, 与最小生成树相似, 是最短网络的一种. 最小生成树是在给定的点集和边中寻求最短网络使所有点连通. 而最小斯坦纳树允许在给定点外增加额外的点, 使生成的最短网络开销最小.</li>
</ol>
<h4 id="3-组合优化问题"><a href="#3-组合优化问题" class="headerlink" title="3. 组合优化问题"></a>3. 组合优化问题</h4><ol>
<li>着色<br>NP-完全问题, 分为点着色, 边着色和m-着色等.</li>
<li>覆盖<ol>
<li>最小边覆盖</li>
<li>最小顶点覆盖</li>
<li>最小路径覆盖</li>
</ol>
</li>
<li>拓扑排序<ul>
<li>有向无环图</li>
<li>如果存在边 <code>u, v</code>, 则 <code>u</code> 将在 <code>v</code> 上方</li>
</ul>
</li>
</ol>
<h4 id="4-流"><a href="#4-流" class="headerlink" title="4. 流"></a>4. 流</h4><ol>
<li>最小和最大流<ol>
<li>增广路径算法</li>
<li>最短增广路算法(SAP)</li>
<li>Dicnic算法<br><code>节点 &gt;&gt; 路径</code> 时应该用SAP, <code>路径 &gt;&gt; 节点</code> 时用Dinic.</li>
<li>最高标号预流推进算法(HLPP)<br>已知几乎效率最高, 但是代码量大且不好理解, 采用预流推进的方法.</li>
</ol>
</li>
<li>最小费用最大流<ol>
<li>Bellman-Ford<br>可以解决负权边, 但是不能解决负环.</li>
<li>SPFA算法<br>在稀疏图上十分高效, 但一般情况下速度较慢.</li>
<li>改进的Dijkstra算法<br>无法直接处理负权边图, 但是速度较快.</li>
</ol>
</li>
<li>匹配问题<ol>
<li>一般图的最大匹配<br>带花树算法, <a href="https://www.cnblogs.com/BAJimH/p/10569418.html" target="_blank" rel="noopener">优秀文章链接</a></li>
<li>二分图的最大匹配<br>匈牙利算法, <a href="https://blog.csdn.net/u013384984/article/details/90718287" target="_blank" rel="noopener">优秀文章链接</a></li>
</ol>
</li>
</ol>
<h3 id="时间序列模型"><a href="#时间序列模型" class="headerlink" title="时间序列模型"></a>时间序列模型</h3><p>带有时间戳的一系列数据被成为时间序列, 对该序列建模被称为时间序列建模.<br>时间序列的分析可以从 <code>频域</code> 和 <code>时间域</code> 进行分析.<br>时间序列一个很重要的性质就是平稳性, 其中又分为严平稳和宽平稳.<br>对于平稳性不是很好的时间序列, 可以通过差分法(类似求导)使其获得较好的平稳性.</p>
<ol>
<li>自回归模型(AR)<br>描述当前值与历史值之间的关系, 用历史值对当前值进行预测.</li>
<li>移动平均模型(MA)<br>移动平均模型较为关注自回归模型中误差项的累加, 能较好的消除预测中的随机波动.</li>
<li>差分自回归<br>是差分, 自回归模型和移动平均模型的结合.</li>
<li>定参<br>对于以上两个模型, 我们可以使用一些具体的算法求解阶数(例如ACF自相关函数的拖尾和截尾)</li>
</ol>
<h3 id="微分方程模型"><a href="#微分方程模型" class="headerlink" title="微分方程模型"></a>微分方程模型</h3><p>关键点在于如何找到一步的变化 $dv/dt$, 在正式的比赛中感觉十分鸡肋.</p>
<h3 id="基本机器学习模型"><a href="#基本机器学习模型" class="headerlink" title="基本机器学习模型"></a>基本机器学习模型</h3><ol>
<li>线性回归<ol>
<li>如果目标是预测或者映射, 线性回归可以用来对观测数据集的和X的值拟合出一个预测模型. 当完成这样一个模型以后, 对于一个新增的 $X$ 值, 在没有给定与它相配对的 $y$ 的情况下, 可以用这个拟合过的模型预测出一个y值.</li>
<li>给定一个变量 $y$ 和一些变量 $X_1,…,X_p$, 这些变量有可能与 $y$ 相关, 线性回归分析可以用来量化 $y$ 与 $X_j$ 之间相关性的强度, 评估出与 $y$ 不相关的$X_j$, 并识别出哪些 $X_j$ 的子集包含了关于 $y$ 的冗余信息.</li>
</ol>
</li>
<li>梯度下降<br>对函数求梯度, 也就是收敛的方向.<br>如果模型复杂, 则可以使用随机梯度下降法或者批量梯度下降法.</li>
<li>逻辑回归<br>虽然叫做回归, 但其实是分类模型, 尤其针对二分类问题, 本质是: 假设数据服从这个分布, 然后使用极大似然估计做参数的估计.</li>
<li>主成分分析(PCA)<br>是一种矩阵降维方法, 可以降低算法的开销, 并且达到一定的去除噪声的作用. 具体的实现方法是通过奇异值分解协方差矩阵得到的, 在 <code>sklearn</code> 库中可以直接调用.</li>
</ol>
<h3 id="深度学习方法"><a href="#深度学习方法" class="headerlink" title="深度学习方法"></a>深度学习方法</h3><ol>
<li>NN</li>
<li>ResNet</li>
<li>CNN</li>
<li>RNN</li>
<li>LSTM</li>
<li>GCN</li>
<li>Transformer</li>
<li>更多模型详见<a href="https://blog.csdn.net/clover_my/article/details/90211793" target="_blank" rel="noopener">链接</a></li>
<li>该博主的<a href="https://blog.csdn.net/clover_my/article/details/90203146" target="_blank" rel="noopener">其他讲解</a></li>
</ol>
<h3 id="数据处理方法"><a href="#数据处理方法" class="headerlink" title="数据处理方法"></a>数据处理方法</h3><ol>
<li>数据清洗<ol>
<li>填入有效数据<ul>
<li>删除法</li>
<li>高频代替法</li>
<li>均值法</li>
<li>插值法</li>
<li>回归法</li>
<li>聚类法</li>
</ul>
</li>
<li>平滑数据噪声<ul>
<li>移动平均模型</li>
<li>中值滤波</li>
<li>盒子法</li>
<li>高斯窗法</li>
<li>聚类法</li>
<li>函数拟合法</li>
</ul>
</li>
<li>检测和处理异常值<ul>
<li>近邻检测</li>
<li>3 $\sigma$ 原则</li>
<li>聚类检测</li>
</ul>
</li>
</ol>
</li>
<li>数据集成<ol>
<li>多个数据集结合</li>
<li>解决不一致性(单位)</li>
<li>特征编码</li>
<li>数据分类<ul>
<li>决策树(ID3算法)</li>
<li>支持向量机(SVM)</li>
<li>随机森林</li>
<li>神经网络</li>
<li>K-means聚类</li>
<li>DBSCAN</li>
</ul>
</li>
</ol>
</li>
<li>数据标准化<br>除了最基本的归一化, 去单位化以外, 还应当规定分位数等, 同时也可以做一些数学变化(如取对数).</li>
<li>数据归约<br>在可能获得相似结果的前提下, 对数据进行缩减(PCA等), 或者以区间代替单值.</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数学建模大赛</tag>
      </tags>
  </entry>
  <entry>
    <title>seaborn进行数据可视化</title>
    <url>/2021/1/18/seaborn%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Seaborn</code> 是基于 <code>matplotlib</code> 的图形可视化 <code>python</code> 包. 它提供了一种高度交互式界面, 便于用户能够做出各种有吸引力的统计图表.</p>
<p><code>Seaborn</code> 是在 <code>matplotlib</code> 的基础上进行了更高级的API封装, 从而使得作图更加容易, 在大多数情况下使用 <code>seaborn</code> 能做出很具有吸引力的图, 而使用 <code>matplotlib</code> 就能制作具有更多特色的图. 应该把 <code>Seaborn</code> 视为 <code>matplotlib</code> 的补充, 而不是替代物. 同时它能高度兼容 <code>numpy</code> 与 <code>pandas</code> 数据结构以及 <code>scipy</code> 与 <code>statsmodels</code> 等统计模式.</p>
<a id="more"></a>

<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>

<h3 id="选定主题"><a href="#选定主题" class="headerlink" title="选定主题"></a>选定主题</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.set_style()</span><br></pre></td></tr></table></figure>

<h3 id="选择数据集"><a href="#选择数据集" class="headerlink" title="选择数据集"></a>选择数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'fmri.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    fmri = pd.read_csv(f, <span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.lineplot(x=<span class="string">"timepoint"</span>, y=<span class="string">"signal"</span>,</span><br><span class="line">             hue=<span class="string">"region"</span>, style=<span class="string">"event"</span>,</span><br><span class="line">             data=fmri)</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.despine() <span class="comment"># 去除多余线</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有一说一真就是全部调包, 感觉不需要什么特性, 临时查起来会快很多……<br>还是放一个中文处理的办法(虽然并不能用上)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">'font.family'</span>] = [<span class="string">'Arial Unicode MS'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br><span class="line">sns.set_style(<span class="string">'whitegrid'</span>, &#123;<span class="string">'font.sans-serif'</span>: [<span class="string">'Arial Unicode MS'</span>, <span class="string">'Arial'</span>]&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数学建模大赛</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人学</title>
    <url>/2021/9/13/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="工业机器人"><a href="#工业机器人" class="headerlink" title="工业机器人"></a>工业机器人</h2><h3 id="机械结构"><a href="#机械结构" class="headerlink" title="机械结构"></a>机械结构</h3><p>工业机器人是由机械结构或<em>机械手</em>、<em>执行器</em>、<em>传感器</em>和<em>控制系统</em>组成.<br>机械手结构是由<em>机械零部件</em>和<em>机械构型</em>组成.</p>
<blockquote>
<p>机器人通常由串联的”链式结构”组成: <em>links 连杆</em>, <em>joints 关节</em>.<br>关节连接两个连杆.</p>
</blockquote>
<a id="more"></a>

<h3 id="Degree-of-Freedom-自由度"><a href="#Degree-of-Freedom-自由度" class="headerlink" title="Degree of Freedom 自由度"></a>Degree of Freedom 自由度</h3><p>理想情况下, 每个关节都有<code>1</code>自由度 (自由度=关节数).<br>工业机器人通常都有<code>6</code>自由度, 但是<code>3</code>, <code>4</code>, <code>5</code>和<code>7</code>自由度也很常见.</p>
<h3 id="关节类型"><a href="#关节类型" class="headerlink" title="关节类型"></a>关节类型</h3><ol>
<li>平移关节 <code>Prismatic(Translational, Linear, Rectilinear) joints</code>: 允许两关节之间直线相对运动.</li>
<li>旋转关节 <code>Revolute (Rotational) joints</code>: 旋转使两杆之间产生相对弧度.</li>
</ol>
<h3 id="机械构型"><a href="#机械构型" class="headerlink" title="机械构型"></a>机械构型</h3><ol>
<li>Cartesian (or Rectangular) 笛卡尔 (直角座标) 型 <code>PPP</code></li>
<li>Cylindrical 圆柱坐标型 <code>RPP</code></li>
<li>Spherical (or Polar) 球形 <code>RRP</code></li>
<li>Jointed (or Revolute) 关节型 <code>RRR</code></li>
<li>SCARA 选择顺应性装配机器手臂^[用于垂直方向组装任务] <code>RRP</code></li>
</ol>
<h2 id="机器人运动学"><a href="#机器人运动学" class="headerlink" title="机器人运动学"></a>机器人运动学</h2><ul>
<li>正运动学: 给定一组关节变量, 根据任务坐标系确定末端执行器的位置和方向, $\theta\to\overrightarrow{x}$.</li>
<li>逆运动学: 给定末端执行器的位置和方向, 求解机器人机械手对应的关节变量 $\theta\to\overrightarrow{x}$.</li>
</ul>
<h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>旋转矩阵表示一个坐标系, 即坐标系的方向.</p>
<blockquote>
<p>将坐标轴的方向作为列向量列出, 就得到了坐标系的旋转矩阵.</p>
</blockquote>
<h3 id="刚体的位置和方向的表示"><a href="#刚体的位置和方向的表示" class="headerlink" title="刚体的位置和方向的表示"></a>刚体的位置和方向的表示</h3><p>设置两个坐标系, 固定参考系: $\Sigma_W:O_{xyz}$ 和固定于物体上的目标对象坐标系: $\Sigma_O:C_{x_oy_oz_o}$<br>运动坐标系的位置和方向可以用来表征物体的位置和方向.<br><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E5%88%9A%E4%BD%93%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E6%96%B9%E5%90%91%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg" alt="刚体的位置和方向的表示"></p>
<blockquote>
<p>位置: 向量OC.<br>姿态, 方向: 相对于参考系, 目标对象坐标系的旋转矩阵.</p>
</blockquote>
<h3 id="齐次变换矩阵"><a href="#齐次变换矩阵" class="headerlink" title="齐次变换矩阵"></a>齐次变换矩阵</h3><p>一个 <code>4x4</code> 的矩阵, 且总是满秩的.</p>
<p>$$^AT_B=\begin{pmatrix}^AR_B&amp;\overrightarrow{p}\0_{1\times3}&amp;1\end{pmatrix}$$</p>
<ol>
<li>用来表示坐标变换<br>$$\begin{pmatrix}^A\overrightarrow{r}\1\end{pmatrix}=^AT_B\begin{pmatrix}^B\overrightarrow{r}\1\end{pmatrix}$$</li>
<li>可用来表示两个坐标系之间的关系<br><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="坐标系之间的关系"></li>
<li>表示目标对象的位置和方向</li>
<li>表示平移和旋转<ul>
<li>仅平移: $D(\overrightarrow{p})=\begin{pmatrix}I_{3\times3}&amp;\overrightarrow{p}\0_{1\times3}&amp;1\end{pmatrix}$</li>
<li>仅旋转: $Rot(R)=\begin{pmatrix}R&amp;0_{3\times1}\0_{1\times3}&amp;1\end{pmatrix}$</li>
<li>平移 + 旋转: $T(R,\overrightarrow{p})=\begin{pmatrix}R&amp;\overrightarrow{p}\0_{1\times3}&amp;1\end{pmatrix}$</li>
</ul>
</li>
</ol>
<h3 id="D-H-表示法-这种连杆坐标系的确定方法称为-Denavit-Hartenberg-D-H-表示法"><a href="#D-H-表示法-这种连杆坐标系的确定方法称为-Denavit-Hartenberg-D-H-表示法" class="headerlink" title="D-H 表示法^[这种连杆坐标系的确定方法称为 Denavit-Hartenberg (D-H) 表示法]"></a>D-H 表示法^[这种连杆坐标系的确定方法称为 Denavit-Hartenberg (D-H) 表示法]</h3><h4 id="建立坐标系"><a href="#建立坐标系" class="headerlink" title="建立坐标系"></a>建立坐标系</h4><p><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E4%B8%AD%E9%97%B4%E8%BF%9E%E6%9D%86.jpg" alt="中间连杆"></p>
<ol>
<li>$Z_{i-1}$: 沿关节 <code>i-1</code> 的中心轴, 建立在运动轴上</li>
<li>$X_{i-1}$: 沿中心轴 <code>i-1</code> 和 <code>i</code> 的公垂线，并指向 $i$ 轴</li>
<li>$Y_{i-1}$: $z_{i-1},x_{i-1}$ 右手螺旋法则</li>
<li>$O_{i-1}$: 中心轴 <code>i-1</code> 与公垂线的交点</li>
</ol>
<blockquote>
<p>如果有多个可能的方向, 可以尽可能的同 <code>i-1</code> 的方向对齐.</p>
</blockquote>
<h4 id="运动学参数"><a href="#运动学参数" class="headerlink" title="运动学参数"></a>运动学参数</h4><p><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E8%BF%90%E5%8A%A8%E5%AD%A6%E5%8F%82%E6%95%B0.jpg" alt="运动学参数"></p>
<ol>
<li>连杆长度 $a_{i-1}$: 沿 $x_{i-1}$, $z_{i-1}$ 到 $z_i$ 的距离</li>
<li>连杆偏转角 $\alpha_{i-1}$: $z_{i-1}$ 和 $z_i$ 间相对于 $x_{i-1}$ 的夹角</li>
<li>关节偏移量 $d_i$: 沿 $z_i$ 方向上, $x_{i-1}$ 到 $x_i$ 的距离</li>
<li>关节角度 $\theta_i$: 相对于 $z_i$, $x_{i-1}$ 和 $x_i$ 之间的夹角</li>
</ol>
<p><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/DH%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="DH表示法"></p>
<h4 id="连杆坐标系间变换矩阵的确定"><a href="#连杆坐标系间变换矩阵的确定" class="headerlink" title="连杆坐标系间变换矩阵的确定"></a>连杆坐标系间变换矩阵的确定</h4><ol>
<li>绕 $X_{i-1}$ 旋转 $\alpha_{i-1}$ 角, $\implies z’_{i-1}||z_i$</li>
<li>沿 $X_{i-1}$ 轴平移 $a_{i-1}$, $\implies O_{i-1}$ is at A</li>
<li>绕 $Z_i$ 轴旋转 $\theta_i$ 角, $\implies x’’_{i-1}||x_i$</li>
<li>沿 $Z_i$ 轴平移一段距离 $d_i$, $\implies$ 两坐标重合</li>
</ol>
<p><strong>齐次变换矩阵:</strong></p>
<p>$$\begin{aligned}<br>^{i-1}T_i&amp;=Rot_x(\alpha_{i-1})D_x(a_{i-1})Rot_z(\theta_i)D_z(d_i)\<br>&amp;=\begin{pmatrix}1&amp;0&amp;0&amp;0\0&amp;c_{\alpha_{i-1}}&amp;-s_{\alpha_{i-1}}&amp;0\0&amp;s_{\alpha_{i-1}}&amp;c_{\alpha_{i-1}}&amp;0\0&amp;0&amp;0&amp;1\end{pmatrix}\begin{pmatrix}1&amp;0&amp;0&amp;a_{i-1}\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;0\0&amp;0&amp;0&amp;1\end{pmatrix}\begin{pmatrix}c_{\theta_i}&amp;-s_{\theta_i}&amp;0&amp;0\s_{\theta_i}&amp;c_{\theta_i}&amp;0&amp;0\0&amp;0&amp;1&amp;0\0&amp;0&amp;0&amp;1\end{pmatrix}\begin{pmatrix}1&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;d_i\0&amp;0&amp;0&amp;1\end{pmatrix}\<br>&amp;=\begin{pmatrix}c_{\theta_i}&amp;-s_{\theta_i}&amp;0&amp;a_{i-1}\s_{\theta_i}c_{\alpha_{i-1}}&amp;c_{\theta_i}c_{\alpha_{i-1}}&amp;-s_{\alpha_{i-1}}&amp;-s_{\alpha_{i-1}}d_i\s_{\theta_i}s_{\alpha_{i-1}}&amp;c_{\theta_i}s_{\alpha_{i-1}}&amp;c_{\alpha_{i-1}}&amp;c_{\alpha_{i-1}}d_i\0&amp;0&amp;0&amp;1\end{pmatrix}<br>\end{aligned}$$</p>
<h2 id="逆运动学"><a href="#逆运动学" class="headerlink" title="逆运动学"></a>逆运动学</h2><p>给定末端执行器的期望位置(P)和姿态(R): $Y=(x,y,z,O,A,T)$, 找出能使机器人达到期望构型的关节变量: $q=(\theta_1,\theta_2,\dots,\theta_n)$</p>
<p>工作空间分为: <em>灵活运动空间<em>和</em>可达运动空间</em></p>
<h3 id="可解性"><a href="#可解性" class="headerlink" title="可解性"></a>可解性</h3><p>给定 $^0_6T$ 中的 16 个元素值, 求解 6 个关节角 $\theta_1,\theta_2,\dots,\theta_6$</p>
<blockquote>
<p>最终有 6 个方程和 6 个自由度</p>
</blockquote>
<ul>
<li>非线性超越方程, 故不总是有闭环解</li>
<li>具有多解性</li>
<li>求解方法<ul>
<li>闭环解(解析解)<ul>
<li>试错法</li>
<li>代数法</li>
<li>几何法</li>
</ul>
</li>
<li>数值解</li>
</ul>
</li>
</ul>
<h3 id="雅可比矩阵"><a href="#雅可比矩阵" class="headerlink" title="雅可比矩阵"></a>雅可比矩阵</h3><ul>
<li>关节速度与末端执行器速度的映射关系</li>
<li>关节与末端执行器之间的微分运动关系</li>
<li>关节力矩与作用在末端执行器上的力的映射关系</li>
</ul>
<p>$$\dot{\vec{x}}=J(\vec{\theta})\dot{\vec{\theta}}$$</p>
<p>如果:</p>
<p>$$^0T_{end-effector}=\begin{pmatrix}R(\vec{\theta})&amp;\vec{p}(\vec{\theta})\0_{1\times3}&amp;1\end{pmatrix}$$</p>
<p>那么:</p>
<p>$$J(\vec{\theta})=\begin{pmatrix}\dfrac{\partial\vec{p}(\vec{\theta})}{\partial\vec{\theta}}\\B(\vec{\theta})\end{pmatrix}$$</p>
<p>其中</p>
<p>$$B(\vec{\theta})=\begin{pmatrix}\xi_1<del>^0\vec{z}_1&amp;\xi_2</del>^0\vec{z}_2&amp;\dots&amp;\xi_n~^0\vec{z}_n\end{pmatrix}$$</p>
<h3 id="冗余机械臂"><a href="#冗余机械臂" class="headerlink" title="冗余机械臂"></a>冗余机械臂</h3><p>当 $n&gt;m$ 时, 关节数量大于末端执行器的自由度, 则机械臂为冗余系统.</p>
<p>$$\dot{\vec{\theta}}=J^+(\vec{\theta})\dot{\vec{x}}+(I-J^+(\vec{\theta})J(\vec{\theta}))\vec{k}$$</p>
<p>其中:</p>
<p>$$J^+(\vec{\theta})=J^T(\vec{\theta})(J(\vec{\theta})J^T(\vec{\theta}))^{-1}$$</p>
<h3 id="等效性"><a href="#等效性" class="headerlink" title="等效性"></a>等效性</h3><p>取关节的微分运动参数为 $\partial\vec{\theta}$, 末端微分运动参数为 $\partial\vec{x}$, 有:</p>
<p>$$\partial\vec{x}=J(\vec{\theta})\partial\vec{\theta}$$</p>
<p>$$\vec{\tau}=J^T(\vec{\theta})\vec{f}$$</p>
<h2 id="机器人传感器和执行器"><a href="#机器人传感器和执行器" class="headerlink" title="机器人传感器和执行器"></a>机器人传感器和执行器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>机器人传感器可以分为两类: <em>内部传感器</em> 和 <em>外部传感器</em>, 内部传感器获取机器人本身的信息, 外部传感器获取周围环境中的信息.</p>
<p>传感器特性</p>
<ul>
<li>灵敏度: 对输入变化有多敏感</li>
<li>线形度: 关系有多线形相关性</li>
<li>准确性: 与实际值之间的差距</li>
<li>解析度: 最小测量增量</li>
<li>响应时间: 响应输入变化的速度</li>
<li>测量范围: 感应范围</li>
</ul>
<h3 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h3><ol>
<li>位置测量<ul>
<li><em>光学编码器</em>: 测量电机轴的旋转角度, 由光束, 光检测器和带光栅的转盘组成</li>
<li><em>电位计</em>: 改变电阻测量</li>
</ul>
</li>
<li>速度测量:<ul>
<li><em>位置差分</em>: 采用位置传感器</li>
</ul>
</li>
<li>惯性传感器:<ul>
<li><em>陀螺仪</em>: 航向传感器, 将方向保持在固定框架上, 移动系统航向的绝对测量</li>
</ul>
</li>
<li>加速度计:<ul>
<li><em>光束偏移</em>: 静态应用中的倾斜传感器, 振动分析, 完整 INS 系统</li>
</ul>
</li>
<li>力传感器:<ul>
<li><em>测量挠度</em>: 将形变转化为电阻的变化</li>
</ul>
</li>
<li>距离传感器:<ul>
<li><em>三角测量</em>: 通过信号传播路径形成的三角形来判断距离</li>
<li><em>飞行时间</em>: 通过信号的飞行时间来判断距离</li>
</ul>
</li>
<li>视觉:<ul>
<li><em>相机透视投影</em>: 利用物理特性计算三维坐标</li>
<li><em>立体视觉</em>: 用两个摄像机测量深度, 类似人眼</li>
</ul>
</li>
<li>触觉传感器:<ul>
<li><em>力敏电阻器</em>: 将压力转变为电阻值变化</li>
</ul>
</li>
</ol>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><ol>
<li>电动执行器: 小尺寸, 反应灵敏, 控制精度高, 但输出功率较低</li>
<li>液压执行器: 大功率输出, 但是大尺寸, 难以控制, 控制精度低, 且脏</li>
<li>气动执行器: 同样大功率, 更加难以控制, 但是成本低, 比较干净, 也较小 (主要用于机械手的打开控制)</li>
<li>其他 (SMA, heat 等)</li>
</ol>
<h2 id="机器人动力学"><a href="#机器人动力学" class="headerlink" title="机器人动力学"></a>机器人动力学</h2><p>机器人动力学研究机器人运动与作用在机器人上的力/力矩之间的关系</p>
<h3 id="前置概要"><a href="#前置概要" class="headerlink" title="前置概要"></a>前置概要</h3><p>速度可以通过 $\omega$ 和 $r_p$ 的叉乘确定, $v$ 的方向由右手定则决定.</p>
<p>$$v=\omega\times r_p=\omega\times r$$</p>
<p>$P$ 的加速度可以通过速度微分来定义.</p>
<p>$$a=\dfrac{dv}{dt}=\dfrac{d\omega}{dt}\times r_p+\omega\times\dfrac{dr_p}{dt}=\alpha\times r_p+\omega\times(\omega\times r_p)$$</p>
<p>也可以简化为</p>
<p>$$a=a\times r-w^2r=a_t+a_n$$</p>
<h3 id="动量"><a href="#动量" class="headerlink" title="动量"></a>动量</h3><ul>
<li>线动量: $L=mV$</li>
<li>角动量: $H_o=r\times mV$</li>
<li>质点系的线动量和角动量:<br>$$L=\sum m_iV_i=\sum m_i\dfrac{d}{dt}r_i=MV_c,\dot{L}=\sum m_i\dfrac{d^2}{dt^2}r_i=\sum(f_i+\sum e_{ij})$$<br>$$\dot{H_o}=\sum\dfrac{d}{dt}{r_i\times mV_i}=M_o$$</li>
<li>刚体的线动量和角动量:<br>$$L=mV_c,H_c=I\omega$$</li>
</ul>
<h3 id="牛顿方程和欧拉方程"><a href="#牛顿方程和欧拉方程" class="headerlink" title="牛顿方程和欧拉方程"></a>牛顿方程和欧拉方程</h3><p>$$ma_c=F=\sum f_i$$<br>$$\dfrac{d}{dt}^AH_c=M_c\implies I\dot{\omega}+\omega\times(^AI\omega)=\sum r_i\times f_i+\sum n_i$$</p>
<ul>
<li>角速度是关于平移坐标系的</li>
<li>惯性张量矩阵是关于平移坐标系的, 所以会随物体的旋转而改变</li>
<li>力和力矩是外部力/力矩的和</li>
</ul>
<h3 id="拉格朗日公式"><a href="#拉格朗日公式" class="headerlink" title="拉格朗日公式"></a>拉格朗日公式</h3><p>基于能量和做功的原理, 机械系统的能量来自动能和势能.</p>
<ul>
<li>动能: 质点移动时具有动能, 动能始终大于0, $K=\sum\frac{1}{2}m_iV_i^2$</li>
<li>势能: 仅考虑重力势能, 取$z$为质点相对于参考水平面的高度, $U=mgz$</li>
<li>做功: 质点在恒力$f$作用下发生位移$r$, 力对质点所做的功为$W=f^Tr=\int m\frac{dV}{dt}dr=\Delta K$</li>
</ul>
<p>定义 $q$ 为系统的广义坐标, $K$ 为系统的动能, $U$ 为系统的势能, $F$ 为系统所受的广义力, 那么有:</p>
<p>$$\dfrac{d}{dt}\dfrac{\partial L}{\partial\dot{q}}-\dfrac{\partial L}{\partial q}=F$$</p>
<ol>
<li>选择广义坐标 $q$(通常使用 <code>D-H</code> 方法定义的运动学参数)</li>
<li>求解施加在系统上并做功的非保守力</li>
<li>计算动能 $K$ 和势能 $U$, 然后 $L=K-U$</li>
<li>计算偏导数</li>
<li>计算广义力 $F$</li>
<li>应用拉格朗日方程</li>
</ol>
<p><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%B3%951.jpg" alt="拉格朗日法1"><br><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%B3%952.jpg" alt="拉格朗日法2"><br><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%B3%953.jpg" alt="拉格朗日法3"></p>
<h3 id="机器人动力学的结构"><a href="#机器人动力学的结构" class="headerlink" title="机器人动力学的结构"></a>机器人动力学的结构</h3><p>由拉格朗日公式我们可以得到</p>
<p>$$\tau=H(q)\ddot{q}+C(q,\dot{q})+G(q)\\tau=H(q)\ddot{q}+\big(\dfrac{1}{2}\dot{H}(q)+S(q,\dot{q})\big)\dot{q}+G(q)$$</p>
<p>其中, $H$ 代表惯性力, $\dot{H}$ 代表离心力, $S$ 代表科氏力, $G$ 代表重力, $\tau$ 代表关节输入. 有 $H$ 对称且正定, $\frac{1}{2}\dot{q}^TH(q)\dot{q}\ge0$, $S(Q,\dot{q})$ 是斜对称矩阵.</p>
<h3 id="机器人动力学的线性参数化"><a href="#机器人动力学的线性参数化" class="headerlink" title="机器人动力学的线性参数化"></a>机器人动力学的线性参数化</h3><p><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E7%BA%BF%E6%80%A7.jpg" alt="拉格朗日法3"></p>
<h2 id="机器人控制"><a href="#机器人控制" class="headerlink" title="机器人控制"></a>机器人控制</h2><ul>
<li>定义: 根据传感器收集的信息和指令来控制机器人的运动</li>
<li>控制分类: 位置控制, 轨迹控制, 力控制, 混合控制</li>
<li>控制类型: 开环控制, 闭环控制</li>
</ul>
<h3 id="李雅普诺夫稳定性"><a href="#李雅普诺夫稳定性" class="headerlink" title="李雅普诺夫稳定性"></a>李雅普诺夫稳定性</h3><p>如果系统任何初始条件下在平衡态附近的轨迹均能维持在平衡态$X_e$附近，那么可以称为在$X_e$处李雅普诺夫稳定</p>
<p>$$\forall\epsilon&gt;0,\exist\delta&gt;0,\text{ that if }||x(0)-x_e||&lt;\delta,\text{ then }\forall t&gt;0,||x(t)-x_e||&lt;\epsilon$$</p>
<blockquote>
<p>需要注意的是, 稳定性并不意味着当时间趋于无穷时系统的状态会趋于平衡点</p>
</blockquote>
<h3 id="收敛性"><a href="#收敛性" class="headerlink" title="收敛性"></a>收敛性</h3><p>$x_e$在$t_0$处收敛, 对任意$\varepsilon$, 存在$\delta&gt;0$, $T&gt;t_0$, 使得如果$||x(t_0)-x_e||&lt;\delta$, 则对所有$t&gt;T$, 有$||x(t)-x_e||&lt;\varepsilon$.</p>
<h3 id="渐近稳定性"><a href="#渐近稳定性" class="headerlink" title="渐近稳定性"></a>渐近稳定性</h3><p>$X_e$是渐进稳定的, 如果他同时满足稳定和收敛条件.</p>
<blockquote>
<p>全局和局部渐近稳定性<br>指数稳定性</p>
</blockquote>
<h3 id="李雅普诺夫定理"><a href="#李雅普诺夫定理" class="headerlink" title="李雅普诺夫定理"></a>李雅普诺夫定理</h3><p>给定非线性系统:</p>
<p>$$\dot{x}=f(x),x(0)=x_0$$</p>
<p>其平衡点在原点. 令$N$为原点的邻域, $X_0$为区域$N$内一点, 若满足一下条件, 则系统在原点李雅普诺夫稳定.</p>
<p>如果存在目标函数$V(X)$, 且有:</p>
<ul>
<li>$V(x)$在区域$N$中正定</li>
<li>$\dot{V}(x)$在区域$N$中负定或半负定</li>
</ul>
<p>如果$\dot{V}(x)$在区域$N$中负定, 则系统在原点满足渐进稳定.</p>
<h3 id="PD反馈控制"><a href="#PD反馈控制" class="headerlink" title="PD反馈控制"></a>PD反馈控制</h3><p>考虑闭环动力学:</p>
<p>$$H(q)\ddot{q}+\bigg(\dfrac{1}{2}\dot{H}(q)+S(q,\dot{q})\bigg)\dot{q}+G(q)=-A\Delta q-B\dot{q}$$</p>
<p>平衡位置: $\Delta q=-A^{-1}G(q)$, 误差不为0, 有偏移误差.</p>
<p>消除误差的方法:</p>
<ul>
<li>设计机器人使重力项为0</li>
<li>增加增益, 使用高增益控制或者使用具有齿轮比的减速机构</li>
<li>在线补偿重力</li>
<li>使用PID控制</li>
</ul>
<p><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E9%87%8D%E5%8A%9B%E8%A1%A5%E5%81%BF.jpg" alt="重力补偿"><br><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E9%87%8D%E5%8A%9B%E8%A1%A5%E5%81%BF2.jpg" alt="重力补偿2"></p>
<p><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E6%89%AD%E7%9F%A9%E6%8E%A7%E5%88%B6.jpg" alt="扭矩控制"><br><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E6%89%AD%E7%9F%A9%E6%8E%A7%E5%88%B62.jpg" alt="扭矩控制2"><br><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E6%89%AD%E7%9F%A9%E6%8E%A7%E5%88%B63.jpg" alt="扭矩控制3"></p>
<p><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E6%A0%87%E7%A7%B0.jpg" alt="标称"><br><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E6%A0%87%E7%A7%B02.jpg" alt="标称2"><br><img src="/picture/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/%E6%A0%87%E7%A7%B03.jpg" alt="标称3"></p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>机器人</tag>
      </tags>
  </entry>
</search>
